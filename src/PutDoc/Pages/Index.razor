@page "/doc/{docId:guid?}"
@rendermode RenderMode.InteractiveServer
@inject PutDoc.Services.PutDocState State
@inject PutDoc.Services.DocWriterService Writers
@inject NavigationManager Nav

@using PutDoc.Components
@using Microsoft.AspNetCore.Components.Web   

@inject IJSRuntime JS

<ToolbarHub/>

<PageTitle>PutDoc</PageTitle>

<div class="putdoc-shell">

    @if (State.Doc?.Collections?.Count == 0)
    {
        <p>Loading…</p>
    }
    else
    {
        <div class="top-row" style="display: inline-flex"> <h1>PutDoc</h1> 
            <a class="brand" href="/docs" title="PutDoc Library">
                <svg class="logo" viewBox="0 0 24 24" aria-hidden="true">
                    <rect x="1" y="1" width="22" height="22" rx="6" ry="6" fill="#22324a"/>
                    <path d="M7 17V6h6a4 4 0 1 1 0 8h-2v3H7zm4-7h2a2 2 0 1 0 0-4h-2v4z" fill="#8ED4B5"/>
                    <path d="M16 3l5 5h-5z" fill="#CFEADF" opacity=".95"/>
                </svg>
                <span class="app-title">PutDoc</span>
            </a>

            <nav class="nav">
                <a class="nav-link" href="/docs">Library</a>
                @if (State.Meta is not null)
                {
                    <span class="sep" aria-hidden="true"></span>
                    <a class="nav-link" href="@($"/doc/{State.Meta.Id}")" title="Current document">@State.DocName</a>
                }
            </nav>
            
            <div class="status">
                @if (State.Meta is not null)
                {
                    <span class="badge @(State.IsReadOnly ? "ro" : "rw")" title="Editing mode">
                        @(State.IsReadOnly ? "Read-only" : "You’re the writer")
                    </span>

                    <button class="btn" @onclick="TakeControl" disabled="@(!State.IsReadOnly)">Take control</button>
                    <button class="btn" @onclick="ReleaseControl" disabled="@(State.IsReadOnly)">Release</button>

                    <span class="sep" aria-hidden="true"></span>

                    <button class="btn" @onclick="ExportJson">Export</button>
                    
                    <form style="display:inline-flex; gap:.35rem;" @onsubmit="DoRename">
                        <input @bind="_rename" @bind:event="oninput" placeholder="@State.DocName"
                               style="border:1px solid #ccc; border-radius:.375rem; padding:.2rem .4rem;"/>
                        <button class="btn" type="submit" disabled="@string.IsNullOrWhiteSpace(_rename)">Rename</button>
                    </form>
                }
                
                
            </div>
        
        </div>
    
    
        <div class="putdoc-layout" id="putdocLayout" @ref="_layoutRef"
             style="--index-w: 420px; --editor-h: 320px;">
        
            <aside class="index resizable-x">
                <IndexPanel/>
            </aside>

            <div class="v-divider" data-role="v-split" aria-label="Resize index panel" tabindex="0"></div>

            <section class="right">
                <div class="editor">
                    <HtmlEditor/>
                </div>

                <div class="h-divider" data-role="h-split" aria-label="Resize editor panel" tabindex="0"></div>

                <div class="workpane">
                    <WorkPane/>
                </div>
            </section>
        </div>

    }
</div>

@code {
    
    private string _rename = "";
    private async Task DoRename()
    {
        var name = string.IsNullOrWhiteSpace(_rename) ? State.DocName : _rename.Trim();
        if (!string.Equals(name, State.DocName, StringComparison.Ordinal))
            await State.RenameAsync(name);
        _rename = "";
    }
    
    void OnWriterChanged(Guid docId, PutDoc.Services.WriterInfo? info)
    {
        if (State.CurrentDocId != docId) return;
        // We rely on ToolbarHub to toggle State.IsReadOnly; this just forces a repaint.
        InvokeAsync(StateHasChanged);
    }

    async Task TakeControl()
    {
        // Call the hub so it uses the per-window sessionId you already wired.
        try
        {
            await JS.InvokeVoidAsync("eval", "window.putdocEnh.getHub()?.invokeMethodAsync('AcquireDocWriter', true)");
        }
        catch { /* noop */ }
    }

    async Task ReleaseControl()
    {
        try { await JS.InvokeVoidAsync("eval", "window.putdocEnh.getHub()?.invokeMethodAsync('ReleaseDocWriter')"); }
        catch { /* noop */ }
    }
    
    void ExportJson()
    {
        if (State.Meta is null) return;
        Nav.NavigateTo($"/api/docs/{State.Meta.Id}/export", forceLoad: true);
    }

    public void Dispose()
    {
        State.Changed -= OnStateChanged;
        Writers.WriterChanged -= OnWriterChanged;
    }
}

@code {
     private ElementReference _layoutRef;
     string? loadError;
     
     [Parameter] public Guid? docId { get; set; }

     // Track last applied + last requested to avoid duplicate loads
     private Guid? _lastAppliedDocId;
     private Guid? _lastRequestedDocId;

     // Coalesce duplicate in-flight loads of the same doc
     private Task? _inFlightLoad;
     private Guid? _inFlightDocId;

     private bool _navigatedToDefault;

     
     
     
     
     /*
     
     protected override async Task OnParametersSetAsync()
     {
         if (docId is Guid id)
         {
             if (_lastAppliedDocId == id) return;      // idempotent
             
             if (_inFlightLoad is not null && _inFlightDocId == id)
             {
                 await _inFlightLoad;              // just await the existing one
                 return;
             }
             
             string lastLoadedDocId;
             if (_lastAppliedDocId == null) lastLoadedDocId = "NULL";
             else lastLoadedDocId = _lastAppliedDocId.ToString();
             Console.WriteLine($"[Index] OnParametersSet: docId={docId} lastApplied={lastLoadedDocId}");

             _lastRequestedDocId = id;
             _inFlightDocId = id;
             var loadTask = State.LoadAsync(id);
             _inFlightLoad = loadTask;

             try
             {
                 await loadTask;
                 _lastAppliedDocId = id;           // commit after success
             }
             catch
             {
                 // If it failed, clear the "requested" so a retry isn't blocked
                 if (_lastRequestedDocId == id) _lastRequestedDocId = null;
                 throw;
             }
             finally
             {
                 // Clear coalescer if this is still the same task
                 if (_inFlightLoad == loadTask) { _inFlightLoad = null; _inFlightDocId = null; }
             }
             
         }
         else
         {
             if (_navigatedToDefault) return;
             _navigatedToDefault = true;

             var defId = await State.GetDefaultDocIdAsync();
             Nav.NavigateTo($"/doc/{defId}", replace: true);
         }
     } */

     protected override async Task OnParametersSetAsync()
     {
         if (docId is Guid id)
         {
             string lastLoadedDocId;
             if (_lastAppliedDocId == null) lastLoadedDocId = "NULL";
             else lastLoadedDocId = _lastAppliedDocId.ToString();
             Console.WriteLine($"[Index] OnParametersSet: docId={docId} lastApplied={lastLoadedDocId}");

             // One line – coalesces duplicate calls within the circuit
             await State.EnsureLoadedAsync(id);
             await InvokeAsync(StateHasChanged);
             //State.Notify();
             
             // After successful load, mark applied
             _lastAppliedDocId = id;
             Console.WriteLine($"[index] docId={docId} (Applied={_lastAppliedDocId?.ToString() ?? "NULL"})");

             return;
         }

         // No id in route → compute default id and navigate (don’t load it here)
         if (_navigatedToDefault) return;
         _navigatedToDefault = true;

         var defId = await State.GetDefaultDocIdAsync();
         Nav.NavigateTo($"/doc/{defId}", replace: true);
     }
     
     protected override async Task OnInitializedAsync()
     {
         State.Changed += OnStateChanged;

         Writers.WriterChanged += OnWriterChanged;
     }
    
     void OnStateChanged() => _ = InvokeAsync(StateHasChanged);
     
     private bool _splittersInited;
     private DotNetObjectReference<Index>? _selfRef;

     [JSInvokable]
    bool isDirtyOrFrozen() =>  State.IsDirty || (State.IsFrozen != null ? State.IsFrozen() : false);

    public Guid? _writerAcquiredFor = null;
    
     protected override async Task OnAfterRenderAsync(bool firstRender)
     {
         if (firstRender)
         {
             _selfRef = DotNetObjectReference.Create(this);
             await JS.InvokeVoidAsync("putdocNav.bindBeforeUnload", isDirtyOrFrozen());
                 //(Func<bool>)(() => State.IsDirty || State.IsFrozen()));
         }
         
         // Acquire doc writer once per loaded doc, after it’s on screen
         if (_lastAppliedDocId is Guid id && _writerAcquiredFor != id)
         {
             _writerAcquiredFor = id;
             try
             {
                 await JS.InvokeVoidAsync("putdocAcquireWriter");
             }
             catch { /* swallow – not fatal */ }
         }
         
         // The layout exists only after the doc/page is loaded.
         if (!_splittersInited && State.Doc is not null && (State.Doc.Collections?.Count ?? 0) > 0)
         {
             _splittersInited = true;
             // give the DOM a tick
             await Task.Yield();
             await JS.InvokeVoidAsync("putdocLayout.initSplitters", "#putdocLayout");
         }
     }
}

@if (!string.IsNullOrEmpty(loadError))
{
    <div style="color:#b00; padding:.75rem; border:1px solid #f2c; background:#fee;">
        Failed to load .putDoc: @loadError
    </div>
}

<style>/* visual cue for active fragment */
[data-selected="true"] {
  outline: 2px solid #5a7cff;
  outline-offset: 2px;
  box-shadow: 0 0 0 3px rgba(90,124,255,.15);
  transition: box-shadow .15s ease, outline-color .15s ease;
}
</style>

<style>
    .app-header {
        display:flex; align-items:center; justify-content:space-between;
        gap:.75rem; padding:.5rem .65rem; background:#fff;
        border:1px solid #224; border-radius:8px; margin-bottom:.5rem;
        position:sticky; top:0; z-index:100;
    }
    .brand { display:flex; align-items:center; gap:.45rem; text-decoration:none; color:#223; }
    .brand .logo { width:22px; height:22px; display:block; }
    .app-title { font-weight:700; letter-spacing:.2px; }

    .nav { display:flex; align-items:center; gap:.5rem; }
    .nav-link { text-decoration:underline; color:#223; background:none; border:0; cursor:pointer; }
    .nav-link:hover { text-decoration:none; }

    .status { display:flex; align-items:center; gap:.35rem; }
    .badge { font-size:.85rem; padding:.1rem .4rem; border-radius:.4rem; border:1px solid #bbb; }
    .badge.rw { background:#e7fff5; border-color:#8ED4B5; }
    .badge.ro { background:#fff7e0; border-color:#e2c26a; }

    /*.sep { width:1px; height:1.25rem; background:#ddd; display:inline-block; }*/

    .btn { padding:.15rem .5rem; border:1px solid #ccc; border-radius:.375rem; background:#fff; cursor:pointer; }
    .btn:hover { background:#f4f4f4; }
    .btn[disabled] { opacity:.55; cursor:not-allowed; }
</style>

<style>
    /* ---------- Global & Header Compensation ---------- */
    :root { --topbar-h: 0px; }          /* set by putdocHeader.init() */
    html, body { height: 100%; margin: 0; }

    article.content {
        padding: 0 !important;
        overflow: hidden;                 /* our grid manages scrollbars */
    }

    /* Optional app background */
    body{
        background-image: url('bgtile_jwc_proxy.png');
        background-repeat: repeat;
        background-size: auto;
        background-attachment: fixed;
    }

    .putdoc-shell {
        height: 100vh;
        display: grid;
        grid-template-rows: auto 1fr; /* header then fill */
    }

    /* ---------- Main Grid (Index | Divider | Right) ---------- */
    .putdoc-layout {
        height: 100%;
        overflow: hidden;                 /* prevent outer scrollbars */
        display: grid;
        grid-template-columns: var(--index-w, 420px) 8px minmax(0,1fr); /* match .v-divider width */
        grid-template-rows: minmax(0,1fr);
    }

    .putdoc-layout { min-height: 0; }
    .right, .editor, .workpane, .index { min-height: 0; }

    /* Left pane (Index) */
    .index {
        border: 1px solid #224; border-radius: 8px; padding: 8px;
        overflow: auto; min-height: 0;
        margin: 4px;
    }

    /* ---------- Right Grid (Editor | Divider | WorkPane) ---------- */
    .right {
        position: relative;               /* stacking context for z-index */
        overflow: hidden;
        display: grid;
        grid-template-rows: var(--editor-h, 320px) 8px minmax(0,1fr);   /* match .h-divider height */
        min-height: 0;
    }

    /* Editor container: flex column, single scroll surface */
    .editor {
        border: 1px solid #224; border-radius: 8px; padding: 8px;
        box-sizing: border-box;
        display: flex; flex-direction: column;
        overflow: hidden;                  /* container does NOT scroll */
        min-height: 0;
        margin: 4px;
    }

    /* Palette row keeps natural height */
    .palette { flex: 0 0 auto;
        display:flex; 
        gap:.35rem; 
        flex-wrap:wrap; 
        margin-bottom:.35rem;
        background-color:#DDF;
        border:1px solid #668; border-radius:8px; padding:.35rem;
    }
    
    /* Textarea fills and is the only scrollable surface */
    .editor textarea {
        flex: 1 1 auto;
        min-height: 0; min-width: 0; width: 100%;
        box-sizing: border-box;
        overflow: auto;
        resize: none;                      /* we have a splitter */
        white-space: pre-wrap;
        overflow-wrap: break-word;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Courier New', monospace;
    }

    /* WorkPane box */
    .workpane {
        border: 1px solid #224; border-radius: 8px; padding: 8px;
        overflow: auto; min-height: 0; margin: 4px;
    }

    /* Ensure panes sit below the divider bars */
    .index, .editor, .workpane { position: relative; z-index: 0; }

    /* ---------- Visible, On-Top Dividers (draggable) ---------- */
    .v-divider, .h-divider {
        background-color: #cfd4e4;          /* visible */
        box-shadow: inset 0 0 0 1px #7a8197;/* subtle line */
        border-radius: 4px;
        margin: 0;
        position: relative;
        z-index: 10;                         /* above scrolling panes */
        touch-action: none; /* allow pointermove without scrolling the page */
    }

    /* Vertical divider between Index and Right */
    .v-divider {
        width: 8px;                          /* keep in sync with grid column */
        cursor: col-resize;
        align-self: stretch;                  /* fill column height */
    }

    /* Horizontal divider between Editor and WorkPane */
    .h-divider {
        height: 8px;                         /* keep in sync with grid row */
        cursor: row-resize;
        justify-self: stretch;               /* fill row width */
    }

    /* (Optional) Keep native handles if you still use them elsewhere */
    .resizable-x { resize: horizontal; }
    .resizable-y { resize: vertical; }


</style>