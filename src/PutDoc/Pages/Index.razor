@page "/doc/{docId:guid?}"
@rendermode RenderMode.InteractiveServer
@inject PutDoc.Services.PutDocState State
@inject PutDoc.Services.DocWriterService Writers
@inject NavigationManager Nav
@inject DebugMutators Debug
@inject Microsoft.Extensions.Hosting.IHostEnvironment Env
@inject PutDoc.Services.InitializationService Init

@using System.Text.Json
@using PutDoc.Components
@using Microsoft.AspNetCore.Components.Web   

@inject IJSRuntime JS
@inject IConfiguration Config

@implements IDisposable


<ToolbarHub/>

<PageTitle>PutDoc</PageTitle>

<div class="putdoc-shell">

    @if (State.Doc?.Collections?.Count == 0)
    {
        <p>Loading…</p>
    }
    else
    {
        <div class="top-row" style="display: inline-flex"> <h1>PutDoc</h1> 
            <a class="brand" href="/docs" title="PutDoc Library">
                <svg class="logo" viewBox="0 0 24 24" aria-hidden="true">
                    <rect x="1" y="1" width="22" height="22" rx="6" ry="6" fill="#22324a"/>
                    <path d="M7 17V6h6a4 4 0 1 1 0 8h-2v3H7zm4-7h2a2 2 0 1 0 0-4h-2v4z" fill="#8ED4B5"/>
                    <path d="M16 3l5 5h-5z" fill="#CFEADF" opacity=".95"/>
                </svg>
                <span class="app-title">PutDoc</span>
            </a>

            <nav class="nav">
                <a class="nav-link" href="/docs">Library</a>
                @if (State.Meta is not null)
                {
                    <span class="sep" aria-hidden="true"></span>
                    <a class="nav-link" href="@($"/doc/{State.Meta.Id}")" title="Current document">@State.DocName</a>
                }
            </nav>
            
            <div class="status">
                @if (State.Meta is not null)
                {
                    <span class="badge @(State.IsReadOnly ? "ro" : "rw")" title="Editing mode">
                        @(State.IsReadOnly ? "Read-only" : "You’re the writer")
                    </span>

                    <button class="btn" @onclick="TakeControl" disabled="@(!State.IsReadOnly)">Take control</button>
                    <button class="btn" @onclick="ReleaseControl" disabled="@(State.IsReadOnly)">Release</button>

                    <span class="sep" aria-hidden="true"></span>

                    <button class="btn" @onclick="ExportJson">Export</button>
                    
                    <form style="display:inline-flex; gap:.35rem;" @onsubmit="DoRename">
                        <input @bind="_rename" @bind:event="oninput" placeholder="@State.DocName"
                               style="border:1px solid #ccc; border-radius:.375rem; padding:.2rem .4rem;"/>
                        <button class="btn" type="submit" disabled="@string.IsNullOrWhiteSpace(_rename)">Rename</button>
                    </form>
                }
                
                
            </div>
        </div>
        
        <RepairBanner />
        
        @if (Env.IsDevelopment() && Config.GetValue<bool>("PutDocDebug_EnableMutators") && State.Doc is not null)
        {
            <div class="menu-popover" style="margin:.5rem 0;">
                <strong>Debug Mutators</strong>
                <div style="display:flex;gap:.5rem;flex-wrap:wrap;margin-top:.35rem;">
                    <button class="btn" @onclick="() => Debug.AddMissingPageRef(State.Doc.RootCollectionId)">+ Missing page ref</button>
                    <button class="btn" @onclick="() => Debug.DuplicateFirstPageRef(State.Doc.RootCollectionId)">Duplicate first page ref</button>
                    <button class="btn" @onclick="() => RemoveFirstPageObject()">Remove first page object</button>
                    <button class="btn" @onclick="() => Debug.AddMissingChildCollectionRef(State.Doc.RootCollectionId)">+ Missing child collection</button>
                    <button class="btn" @onclick="() => Debug.ShufflePages(State.Doc.RootCollectionId)">Shuffle page order</button>
                    <button class="btn" @onclick="() => Debug.AddOrphanPage()">Add orphan page</button>
                </div>
            </div>
        }

@code {
    private void RemoveFirstPageObject()
    {
        var root = State.Doc.Collections.TryGetValue(State.Doc.RootCollectionId, out var c) ? c : null;
        var first = root?.PageIds?.FirstOrDefault() ?? Guid.Empty;
        if (first != Guid.Empty) Debug.RemovePageObjectKeepRefs(first);
    }
}

    
    
        <div class="putdoc-layout" id="putdocLayout" @ref="_layoutRef"
             style="--index-w: 420px; --editor-h: 320px;">

            <aside class="index resizable-x">
                <IndexPanel/>
            </aside>

            <div class="v-divider" data-role="v-split" aria-label="Resize index panel" tabindex="0"></div>

            <section class="right">
                <div class="editor">
                    <HtmlEditor/>
                </div>

                <div class="h-divider" data-role="h-split" aria-label="Resize editor panel" tabindex="0"></div>

                <div class="workpane">
                    <WorkPane/>
                </div>
            </section>
        </div>

    }
</div>

@code {
    
    private string _rename = "";
    private async Task DoRename()
    {
        var name = string.IsNullOrWhiteSpace(_rename) ? State.DocName : _rename.Trim();
        if (!string.Equals(name, State.DocName, StringComparison.Ordinal))
            await State.RenameAsync(name);
        _rename = "";
    }
    
    void OnWriterChanged(Guid docId, PutDoc.Services.WriterInfo? info)
    {
        //if (State.CurrentDocId != docId) return;
        // We rely on ToolbarHub to toggle State.IsReadOnly; this just forces a repaint.
        _ = InvokeAsync(StateHasChanged);
    }

    async Task TakeControl()
    {
        // Call the hub so it uses the per-window sessionId you already wired.
        try
        {
            var v = await JS.InvokeAsync<JsonElement>("putdocAcquireWriter", true);

            //await JS.InvokeVoidAsync("eval", "window.putdocEnh.getHub()?.invokeMethodAsync('AcquireDocWriter', true)");
        }
        catch { /* noop */ }
    }

    async Task ReleaseControl()
    {
        try
        {
            await JS.InvokeVoidAsync("putdocReleaseWriter");
        }
        //try { await JS.InvokeVoidAsync("eval", "window.putdocEnh.getHub()?.invokeMethodAsync('ReleaseDocWriter')"); }
        catch (Exception E)
        {
            /* noop */ 
            
        }
    }
    
    void ExportJson()
    {
        if (State.Meta is null) return;
        Nav.NavigateTo($"/api/docs/{State.Meta.Id}/export", forceLoad: true);
    }

    public void Dispose()
    {
        _ = JS.InvokeVoidAsync("putdocPresence.releaseWriter");

        State.Changed -= OnStateChanged;
        Writers.WriterChanged -= OnWriterChanged;

        State.UiReset -= StateOnUiReset;
    }

}

@code {
    private ElementReference _layoutRef;
     string? loadError;
     
     [Parameter] public Guid? docId { get; set; }

     // Track last applied + last requested to avoid duplicate loads
     private Guid? _lastAppliedDocId;

     private bool _navigatedToDefault;

     private void StateOnUiReset()
     {
         loadError = null;
         _writerAcquiredFor = null;
     }

     
     
     
     
     /*
     
     protected override async Task OnParametersSetAsync()
     {
         if (docId is Guid id)
         {
             if (_lastAppliedDocId == id) return;      // idempotent
             
             if (_inFlightLoad is not null && _inFlightDocId == id)
             {
                 await _inFlightLoad;              // just await the existing one
                 return;
             }
             
             string lastLoadedDocId;
             if (_lastAppliedDocId == null) lastLoadedDocId = "NULL";
             else lastLoadedDocId = _lastAppliedDocId.ToString();
             Console.WriteLine($"[Index] OnParametersSet: docId={docId} lastApplied={lastLoadedDocId}");

             _lastRequestedDocId = id;
             _inFlightDocId = id;
             var loadTask = State.LoadAsync(id);
             _inFlightLoad = loadTask;

             try
             {
                 await loadTask;
                 _lastAppliedDocId = id;           // commit after success
             }
             catch
             {
                 // If it failed, clear the "requested" so a retry isn't blocked
                 if (_lastRequestedDocId == id) _lastRequestedDocId = null;
                 throw;
             }
             finally
             {
                 // Clear coalescer if this is still the same task
                 if (_inFlightLoad == loadTask) { _inFlightLoad = null; _inFlightDocId = null; }
             }
             
         }
         else
         {
             if (_navigatedToDefault) return;
             _navigatedToDefault = true;

             var defId = await State.GetDefaultDocIdAsync();
             Nav.NavigateTo($"/doc/{defId}", replace: true);
         }
     } */

     Guid? toLoad = null;
     
     protected override async Task OnParametersSetAsync()
     {
         if (docId is Guid id)
         {
             toLoad = id;
             return;
         }

         // No id in route → compute default id and navigate (don’t load it here)
         if (_navigatedToDefault) return;
         _navigatedToDefault = true;

         var defId = await State.GetDefaultDocIdAsync();
         Nav.NavigateTo($"/doc/{defId}", replace: true);
     }
     
     protected override async Task OnInitializedAsync()
     {
         State.Changed += OnStateChanged;
         State.UiReset += StateOnUiReset;
         Writers.WriterChanged += OnWriterChanged;
     }
    
     void OnStateChanged() => _ = InvokeAsync(StateHasChanged);
     
     private bool _splittersInited;
     private DotNetObjectReference<Index>? _selfRef;

     [JSInvokable]
    bool isDirtyOrFrozen() =>  State.IsDirty || (State.IsFrozen != null ? State.IsFrozen() : false);

    public Guid? _writerAcquiredFor = null;

    /*
    
    public async Task DelayLoad()
    {
        if (!await JS.InvokeAsync<bool>("putdocEnh.hasHub")) StateHasChanged();
        else if (toLoad is Guid id)
        {
            string lastLoadedDocId;
            if (_lastAppliedDocId == null) lastLoadedDocId = "NULL";
            else lastLoadedDocId = _lastAppliedDocId.ToString();
            Console.WriteLine($"[Index] OnParametersSet: docId={docId} lastApplied={lastLoadedDocId}");

            await State.NotifyAsync(async () =>
            {
                try
                {
                    await JS.InvokeVoidAsync("putdocReleaseWriter");
                }
                catch
                {
                }

                // 2) Reset all component-local UI state
                State.TriggerUiReset();

                // One line – coalesces duplicate calls within the circuit
                await State.EnsureLoadedAsync(id);
                
                // After successful load, mark applied
                _lastAppliedDocId = id;
                toLoad = null;
                
                //_ = Task.Yield();
            });

            Console.WriteLine($"[index] docId={docId} (Applied={_lastAppliedDocId?.ToString() ?? "NULL"})");                    
        }*/
    
    public async Task DelayLoad()
    {
        if (toLoad is not Guid id) return;

        // Wait one frame for the hub (or bail after timeout)
        var hubReady = await JS.InvokeAsync<bool>("putdocWaitForHub", 3000);
        
        /*
        bool hubReady;

        do
        {
            hubReady = await JS.InvokeAsync<bool>("putdocEnh.hasHub");
            if (!hubReady)
            {
                await Task.Yield();
                //StateHasChanged();
                //return;
                // Fallback: proceed anyway; ToolbarHub will still come up later
                // or you can return and let OnAfterRender try again.
            }
        } while (!hubReady);
        */
        Console.WriteLine($"[Index] DelayLoad -> docId={id} lastApplied={_lastAppliedDocId?.ToString() ?? "NULL"}");

        // Important: clear toLoad *before* heavy work to avoid accidental re-entry
        var loadId = id;
        toLoad = null;

        await State.NotifyAsync(async () =>
        {
            try { await JS.InvokeVoidAsync("putdocReleaseWriter"); } catch { /* noop */ }

            State.TriggerUiReset();

            // Coalesced loader (safe to call even if another call is in-flight)
            await State.EnsureLoadedAsync(loadId);

            _lastAppliedDocId = loadId;
        });

        Console.WriteLine($"[Index] Applied={_lastAppliedDocId}");
    }


     protected override async Task OnAfterRenderAsync(bool firstRender)
     {
         await Init.CheckInit();
         
         await DelayLoad();
         
         // Acquire doc writer once per loaded doc, after it’s on screen
         if (_lastAppliedDocId is Guid id && _writerAcquiredFor != id)
         {
             var o = await JS.InvokeAsync<object>("putdocEnh.getHub");
             if (o != null)
             {
                 try
                 {
                     var v = await JS.InvokeAsync<JsonElement>("putdocAcquireWriter", false);
                     var isWriter = v.ValueKind == JsonValueKind.Object
                                    && v.TryGetProperty("status", out var s)
                                    && s.GetString() == "writer";
                     //_writerAcquiredFor = isWriter ? id : null;
                     _writerAcquiredFor = id;
                 }
                 catch
                 {
                     /* swallow – not fatal */
                 }
             }
         }
         
         await JS.InvokeVoidAsync("putdoc.attachFlashToButtons");
         
         if (firstRender)
         {
             _selfRef = DotNetObjectReference.Create(this);
             await JS.InvokeVoidAsync("putdocNav.bindBeforeUnload", isDirtyOrFrozen());
                 //(Func<bool>)(() => State.IsDirty || State.IsFrozen()));
         }
         
         // The layout exists only after the doc/page is loaded.
         if (!_splittersInited && State.Doc is not null && (State.Doc.Collections?.Count ?? 0) > 0)
         {
             _splittersInited = true;
             // give the DOM a tick
             await Task.Yield();
             await JS.InvokeVoidAsync("putdocLayout.initSplitters", "#putdocLayout"); 
         }
     }
}

@if (!string.IsNullOrEmpty(loadError))
{
    <div style="color:#b00; padding:.75rem; border:1px solid #f2c; background:#fee;">
        Failed to load .putDoc: @loadError
    </div>
}

<style>/* visual cue for active fragment */
    [data-selected="true"] {
      outline: 2px solid #5a7cff;
      outline-offset: 2px;
      box-shadow: 0 0 0 3px rgba(90,124,255,.15);
      transition: box-shadow .15s ease, outline-color .15s ease;
    }
    
</style>

<style>
    .app-header {
        display:flex; align-items:center; justify-content:space-between;
        gap:.75rem; padding:.5rem .65rem; background:#fff;
        border:1px solid #224; border-radius:8px; margin-bottom:.5rem;
        position:sticky; top:0; z-index:100;
    }
    .brand { display:flex; align-items:center; gap:.45rem; text-decoration:none; color:#223; }
    .brand .logo { width:22px; height:22px; display:block; }
    .app-title { font-weight:700; letter-spacing:.2px; }

    .nav { display:flex; align-items:center; gap:.5rem; }
    .nav-link { text-decoration:underline; color:#223; background:none; border:0; cursor:pointer; }
    .nav-link:hover { text-decoration:none; }

    .status { display:flex; align-items:center; gap:.35rem; }
    .badge { font-size:.85rem; padding:.1rem .4rem; border-radius:.4rem; border:1px solid #bbb; }
    .badge.rw { background:#e7fff5; border-color:#8ED4B5; }
    .badge.ro { background:#fff7e0; border-color:#e2c26a; }

    /*.sep { width:1px; height:1.25rem; background:#ddd; display:inline-block; }*/

    .btn { padding:.15rem .5rem; border:1px solid #ccc; border-radius:.375rem; background:#fff; cursor:pointer; }
    .btn:hover { background:#f4f4f4; }
    .btn[disabled] { opacity:.55; cursor:not-allowed; }
</style>

<style>
    /* ---------- Global & Header Compensation ---------- */
    :root { --topbar-h: 0px; }          /* set by putdocHeader.init() */
    html, body { height: 100%; margin: 0; }

    article.content {
        padding: 0 !important;
        overflow: hidden;                 /* our grid manages scrollbars */
    }

    /* Optional app background */
    body{
        background-image: url('bgtile_jwc_proxy.png');
        background-repeat: repeat;
        background-size: auto;
        background-attachment: fixed;
    }

    .putdoc-shell {
        height: 100vh;
        display: grid;
        grid-template-rows: auto 1fr; /* header then fill */
    }

    /* ---------- Main Grid (Index | Divider | Right) ---------- */
    .putdoc-layout {
        height: 100%;
        overflow: hidden;                 /* prevent outer scrollbars */
        display: grid;
        grid-template-columns: var(--index-w, 420px) 8px minmax(0,1fr); /* match .v-divider width */
        grid-template-rows: minmax(0,1fr);
    }

    .putdoc-layout { min-height: 0; }
    .right, .editor, .workpane, .index { min-height: 0; }

    /* Left pane (Index) */
    .index {
        border: 1px solid #224; border-radius: 8px; padding: 8px;
        overflow: auto; min-height: 0;
        margin: 4px;
    }

    /* ---------- Right Grid (Editor | Divider | WorkPane) ---------- */
    .right {
        position: relative;               /* stacking context for z-index */
        overflow: hidden;
        display: grid;
        grid-template-rows: var(--editor-h, 320px) 8px minmax(0,1fr);   /* match .h-divider height */
        min-height: 0;
    }

    /* Editor container: flex column, single scroll surface */
    .editor {
        border: 1px solid #224; border-radius: 8px; padding: 8px;
        box-sizing: border-box;
        display: flex; flex-direction: column;
        overflow: hidden;                  /* container does NOT scroll */
        min-height: 0;
        margin: 4px;
    }

    /* Palette row keeps natural height */
    .palette {
        flex: 0 0 auto;
        display:flex;
        gap:.35rem;
        flex-wrap:wrap;
        margin-bottom:.35rem;
        background-color:#DDF;
        border:1px solid #668; border-radius:8px; padding:.35rem;
        overflow: visible; /* allow native popup to escape */
    }

    .editor {
        border: 1px solid #224; border-radius: 8px; padding: 8px;
        box-sizing: border-box;
        display: flex; flex-direction: column;
        overflow: hidden;                  /* keep container */
        min-height: 0;
        margin: 4px;
        position: relative;                /* stacking context */
        z-index: 0;
    }
    /* Textarea fills and is the only scrollable surface */
    .editor textarea {
        flex: 1 1 auto;
        min-height: 0; min-width: 0; width: 100%;
        box-sizing: border-box;
        overflow: auto;
        resize: none;                      /* we have a splitter */
        white-space: pre-wrap;
        overflow-wrap: break-word;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Courier New', monospace;
    }

    /* WorkPane box */
    .workpane {
        border: 1px solid #224; border-radius: 8px; padding: 8px;
        overflow: auto; min-height: 0; margin: 4px;
    }

    /* Ensure panes sit below the divider bars */
    .index, .editor, .workpane { position: relative; z-index: 0; }

    /* ---------- Visible, On-Top Dividers (draggable) ---------- */
    .v-divider, .h-divider {
        background-color: #cfd4e4;          /* visible */
        box-shadow: inset 0 0 0 1px #7a8197;/* subtle line */
        border-radius: 4px;
        margin: 0;
        position: relative;
        z-index: 10;                         /* above scrolling panes */
        touch-action: none; /* allow pointermove without scrolling the page */
    }

    /* Vertical divider between Index and Right */
    .v-divider {
        width: 8px;                          /* keep in sync with grid column */
        cursor: col-resize;
        align-self: stretch;                  /* fill column height */
    }

    /* Horizontal divider between Editor and WorkPane */
    .h-divider {
        height: 8px;                         /* keep in sync with grid row */
        cursor: row-resize;
        justify-self: stretch;               /* fill row width */
    }

    /* (Optional) Keep native handles if you still use them elsewhere */
    .resizable-x { resize: horizontal; }
    .resizable-y { resize: vertical; }


</style>