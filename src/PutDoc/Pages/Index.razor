@page "/doc/{docId:guid?}"
@rendermode RenderMode.InteractiveServer
@inject PutDoc.Services.PutDocState State
@inject PutDoc.Services.DocWriterService Writers
@inject NavigationManager Nav

@using PutDoc.Components
@using Microsoft.AspNetCore.Components.Web   

@inject IJSRuntime JS

<ToolbarHub/>

<PageTitle>PutDoc</PageTitle>

<div class="putdoc-shell">

    @if (State.Doc?.Collections?.Count == 0)
    {
        <p>Loadingâ€¦</p>
    }
    else
    {
        <div class="top-row" style="display: inline-flex"> <h1>PutDoc</h1> 
            <a class="brand" href="/docs" title="PutDoc Library">
                <svg class="logo" viewBox="0 0 24 24" aria-hidden="true">
                    <rect x="1" y="1" width="22" height="22" rx="6" ry="6" fill="#22324a"/>
                    <path d="M7 17V6h6a4 4 0 1 1 0 8h-2v3H7zm4-7h2a2 2 0 1 0 0-4h-2v4z" fill="#8ED4B5"/>
                    <path d="M16 3l5 5h-5z" fill="#CFEADF" opacity=".95"/>
                </svg>
                <span class="app-title">PutDoc</span>
            </a>

            <nav class="nav">
                <a class="nav-link" href="/docs">Library</a>
                @if (State.Meta is not null)
                {
                    <span class="sep" aria-hidden="true"></span>
                    <a class="nav-link" href="@($"/doc/{State.Meta.Id}")" title="Current document">@State.DocName</a>
                }
            </nav>
            
            @if (State.Doc is not null)
            {
                <div style="position:sticky; top:0; z-index:1000; padding:.35rem .5rem;
                background: #fffbe6; border-bottom:1px solid #e6db9e;
                display:flex; gap:.5rem; align-items:center;">
                    <span>
                        @(State.IsReadOnly
                            ? "Read-only in this window"
                            : "You have write control")
                    </span>

                    <button class="btn" @onclick="TakeControl" disabled="@(!State.IsReadOnly)">
                        Take control
                    </button>
                    <button class="btn" @onclick="ReleaseControl" disabled="@(State.IsReadOnly)">
                        Release
                    </button>
                </div>
            }
        
        </div>
    
    
        <div class="putdoc-layout" id="putdocLayout" @ref="_layoutRef"
             style="--index-w: 420px; --editor-h: 320px;">
        
            <aside class="index resizable-x">
                <IndexPanel/>
            </aside>

            <div class="v-divider" data-role="v-split" aria-label="Resize index panel" tabindex="0"></div>

            <section class="right">
                <div class="editor">
                    <HtmlEditor/>
                </div>

                <div class="h-divider" data-role="h-split" aria-label="Resize editor panel" tabindex="0"></div>

                <div class="workpane">
                    <WorkPane/>
                </div>
            </section>
        </div>

    }
</div>

@code {
    
    void OnWriterChanged(Guid docId, PutDoc.Services.WriterInfo? info)
    {
        if (State.CurrentDocId != docId) return;
        // We rely on ToolbarHub to toggle State.IsReadOnly; this just forces a repaint.
        InvokeAsync(StateHasChanged);
    }

    async Task TakeControl()
    {
        // Call the hub so it uses the per-window sessionId you already wired.
        try
        {
            await JS.InvokeVoidAsync("eval", "window.putdocEnh.getHub()?.invokeMethodAsync('AcquireDocWriter', true)");
        }
        catch { /* noop */ }
    }

    async Task ReleaseControl()
    {
        try { await JS.InvokeVoidAsync("eval", "window.putdocEnh.getHub()?..invokeMethodAsync('ReleaseDocWriter')"); }
        catch { /* noop */ }
    }

    public void Dispose()
    {
        State.Changed -= OnStateChanged;
        Writers.WriterChanged -= OnWriterChanged;
    }
}

@code {
     private ElementReference _layoutRef;
     string? loadError;
     
     [Parameter] public Guid? docId { get; set; }

     protected override async Task OnParametersSetAsync()
     {
         if (docId is Guid id)
         {
             if (State.CurrentDocId != id)
                try { await State.LoadAsync(id); }
                catch (Exception ex) { loadError = ex.Message; }

         }
         else
         {
             var _id = await State.LoadDefaultAsync();
             Nav.NavigateTo($"/doc/{_id}", replace: true);
         }
     }

     protected override async Task OnInitializedAsync()
     {
         State.Changed += OnStateChanged;

         Writers.WriterChanged += OnWriterChanged;
     }
    
     void OnStateChanged() => _ = InvokeAsync(StateHasChanged);
     
     private bool _splittersInited;

     protected override async Task OnAfterRenderAsync(bool firstRender)
     {
         // The layout exists only after the doc/page is loaded.
         if (!_splittersInited && State.Doc is not null && (State.Doc.Collections?.Count ?? 0) > 0)
         {
             _splittersInited = true;
             // give the DOM a tick
             await Task.Yield();
             await JS.InvokeVoidAsync("putdocLayout.initSplitters", "#putdocLayout");
         }
     }
}

@if (!string.IsNullOrEmpty(loadError))
{
    <div style="color:#b00; padding:.75rem; border:1px solid #f2c; background:#fee;">
        Failed to load .putDoc: @loadError
    </div>
}

<style>/* visual cue for active fragment */
[data-selected="true"] {
  outline: 2px solid #5a7cff;
  outline-offset: 2px;
  box-shadow: 0 0 0 3px rgba(90,124,255,.15);
  transition: box-shadow .15s ease, outline-color .15s ease;
}
</style>

<style>
    /* ---------- Global & Header Compensation ---------- */
    :root { --topbar-h: 0px; }          /* set by putdocHeader.init() */
    html, body { height: 100%; margin: 0; }

    article.content {
        padding: 0 !important;
        overflow: hidden;                 /* our grid manages scrollbars */
    }

    /* Optional app background */
    body{
        background-image: url('bgtile_jwc_proxy.png');
        background-repeat: repeat;
        background-size: auto;
        background-attachment: fixed;
    }

    .putdoc-shell {
        height: 100vh;
        display: grid;
        grid-template-rows: auto 1fr; /* header then fill */
    }

    /* ---------- Main Grid (Index | Divider | Right) ---------- */
    .putdoc-layout {
        height: 100%;
        overflow: hidden;                 /* prevent outer scrollbars */
        display: grid;
        grid-template-columns: var(--index-w, 420px) 8px minmax(0,1fr); /* match .v-divider width */
        grid-template-rows: minmax(0,1fr);
    }

    .putdoc-layout { min-height: 0; }
    .right, .editor, .workpane, .index { min-height: 0; }

    /* Left pane (Index) */
    .index {
        border: 1px solid #224; border-radius: 8px; padding: 8px;
        overflow: auto; min-height: 0;
        margin: 4px;
    }

    /* ---------- Right Grid (Editor | Divider | WorkPane) ---------- */
    .right {
        position: relative;               /* stacking context for z-index */
        overflow: hidden;
        display: grid;
        grid-template-rows: var(--editor-h, 320px) 8px minmax(0,1fr);   /* match .h-divider height */
        min-height: 0;
    }

    /* Editor container: flex column, single scroll surface */
    .editor {
        border: 1px solid #224; border-radius: 8px; padding: 8px;
        box-sizing: border-box;
        display: flex; flex-direction: column;
        overflow: hidden;                  /* container does NOT scroll */
        min-height: 0;
        margin: 4px;
    }

    /* Palette row keeps natural height */
    .editor .palette { flex: 0 0 auto; }

    /* Textarea fills and is the only scrollable surface */
    .editor textarea {
        flex: 1 1 auto;
        min-height: 0; min-width: 0; width: 100%;
        box-sizing: border-box;
        overflow: auto;
        resize: none;                      /* we have a splitter */
        white-space: pre-wrap;
        overflow-wrap: break-word;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Courier New', monospace;
    }

    /* WorkPane box */
    .workpane {
        border: 1px solid #224; border-radius: 8px; padding: 8px;
        overflow: auto; min-height: 0; margin: 4px;
    }

    /* Ensure panes sit below the divider bars */
    .index, .editor, .workpane { position: relative; z-index: 0; }

    /* ---------- Visible, On-Top Dividers (draggable) ---------- */
    .v-divider, .h-divider {
        background-color: #cfd4e4;          /* visible */
        box-shadow: inset 0 0 0 1px #7a8197;/* subtle line */
        border-radius: 4px;
        margin: 0;
        position: relative;
        z-index: 10;                         /* above scrolling panes */
        touch-action: none; /* allow pointermove without scrolling the page */
    }

    /* Vertical divider between Index and Right */
    .v-divider {
        width: 8px;                          /* keep in sync with grid column */
        cursor: col-resize;
        align-self: stretch;                  /* fill column height */
    }

    /* Horizontal divider between Editor and WorkPane */
    .h-divider {
        height: 8px;                         /* keep in sync with grid row */
        cursor: row-resize;
        justify-self: stretch;               /* fill row width */
    }

    /* (Optional) Keep native handles if you still use them elsewhere */
    .resizable-x { resize: horizontal; }
    .resizable-y { resize: vertical; }


</style>