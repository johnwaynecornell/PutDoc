@using System.Text.Json
@namespace PutDoc.Components
@inject PutDoc.Services.PutDocState State
@inject PutDoc.Services.DocInvalidationService Invalidations
@inject NavigationManager Nav
@inject IJSRuntime JS

@implements IDisposable

<h3 @ref="_scopeAnchor" class="font-semibold mb-2">WorkPane — Snippets in Page</h3>

@if (_staleStructural)
{
    <div class="menu-popover" style="margin:.5rem 0;">
        A structural change happened in another window.
        <button class="btn primary" @onclick="@(() => Nav.NavigateTo(Nav.Uri, forceLoad:true))">Refresh</button>
    </div>
}

@if (State.CurrentPage() is { } _page)
{
    <div class="mb-2"><strong>Page:</strong> @_page.Title</div>

    @foreach (var snip in _page.Snippets)
    {
        <div @key="snip.Id" style="border:1px solid #ddd; border-radius:.5rem; margin-bottom:.75rem;">
            <div style="padding:.75rem; background:rgba(190,220,190,.5);">
                <div class="workpane-snippet"
                     id="@($"snip-{snip.Id}")"
                     data-snippet-id="@snip.Id">
                    @((MarkupString)(snip.Html ?? ""))
                </div>
            </div>

            <div class="palette">
                @* <button type='button' class='btn' disabled="@State.IsReadOnlyOrFrozen" @onclick='() => State.AddSnippetBelow(snip.Id)'>＋</button> *@

                <button type='button' class='btn' disabled="@State.IsReadOnlyOrFrozen" @onclick='() => State.AddSnippetBelow(snip.Id)'>＋</button>
                <button type='button' class='btn' disabled="@State.IsReadOnlyOrFrozen" @onclick='() => State.DeleteSnippet(snip.Id)'>Delete</button>
                <button type='button' class='btn' disabled="@State.IsReadOnlyOrFrozen" @onclick='() => State.CloneSnippet(snip.Id)'>Clone</button>
                <button type='button' class='btn' @onclick='async () => CopyToClipboard(await HtmlPuid.StripPuidsAsync(snip.Html ?? ""))'>Copy</button>
                <button type='button' class='btn' disabled="@State.IsReadOnlyOrFrozen" @onclick='() => State.MoveSnippet(snip.Id, -1)'>↑</button>
                <button type='button' class='btn' disabled="@State.IsReadOnlyOrFrozen" onclick='() => State.MoveSnippet(snip.Id, +1)'>↓</button>

                <!-- Acquire lock before selecting snippet -->
                <button type='button'
                        class='btn @(State.SelectedSnippetId == snip.Id ? "font-bold" : "")'
                        @onclick='() => EditSnippet(snip.Id)'>
                    Edit
                </button>

                <button type='button' class='btn' disabled="@State.IsReadOnlyOrFrozen" @onclick='() => InsertTemplate(snip.Id, TemplateKind.Card)'>+ slf-card</button>
                <button type='button' class='btn' disabled="@State.IsReadOnlyOrFrozen" @onclick='() => InsertTemplate(snip.Id, TemplateKind.Brick)'>+ slf-brick</button>
                <button type='button' class='btn' disabled="@State.IsReadOnlyOrFrozen" @onclick='() => InsertTemplate(snip.Id, TemplateKind.Prompt)'>+ prompt</button>
            </div>
        </div>
    }

    <div>
        <button type="button" class="btn" @onclick="() => State.AddSnippetBelow(_page.Snippets.LastOrDefault()?.Id ?? Guid.Empty)">
            ＋ Add snippet
        </button>
    </div>
}
else
{
    <p style="color:#666;font-style:italic">Select a page from Index.</p>
}

<style>
.btn { padding:.25rem .5rem; border:1px solid #ccc; border-radius:.375rem; background:#fff; cursor:pointer; }
.btn:hover { background:#f4f4f4; }
.font-bold { font-weight:700; }
</style>

@code {
    
    enum TemplateKind { Card, Brick, Prompt }

    private Guid? _lastPageId;
    private Guid? _lastSelectedSnippetId;
    private bool _lastActive = false;
    
    private bool _staleStructural;
    private string _sessionId = "";
    
    async Task CopyToClipboard(string html) =>
        await JS.InvokeVoidAsync("navigator.clipboard.writeText", html);

    async Task InsertTemplate(Guid snippetId, TemplateKind kind)
    {
        var page = State.CurrentPage(); if (page is null) return;
        var snip = page.Snippets.FirstOrDefault(s => s.Id == snippetId); if (snip is null) return;

        var add = kind switch
        {
            TemplateKind.Card   => """<div class="slf-card"><h3>Title</h3><p><b>Purpose</b>: <span>…</span></p><div><b>Content</b>: <div>…</div></div></div>""",
            TemplateKind.Brick  => """<div class="slf-brick"><h3>BRICK</h3><p><b>Definition</b>: <span>…</span></p><div><b>Example</b>: <div>…</div></div></div>""",
            TemplateKind.Prompt => """<div class="prompt_area"><h3>Prompt</h3><p>…</p></div>""",
            _ => ""
        };

        await State.SetSnippetHtml((snip.Html ?? "") + "\n" + add, isRawFromEditor: false);
        
        State.SelectSnippet(snippetId);
    }

    // Acquire a snippet lock (per window) before selecting
    async Task EditSnippet(Guid id)
    {
        
        if (!await State.EnsureClearForTextChangeInternalAsync()) return;

        try
        {
            // (Optional) release any previous lock first to be courteous
            await JS.InvokeVoidAsync("putdocPresence.releaseCurrent");

            var res = await JS.InvokeAsync<JsonElement>("putdocPresence.acquireSnippet", id.ToString(), false);
            var ok =
                (res.TryGetProperty("status", out var s) && s.GetString() is string st &&
                 (st == "granted" || st == "stolen"));

            if (ok)
            {
                State.SelectSnippet(id);
            }
            // else: denied or user cancelled takeover → do nothing
        }
        catch
        {
            // If presence isn’t ready, fall back to selecting (single-user dev mode)
            State.SelectSnippet(id);
        }
    }

    protected override void OnInitialized()
    {
        State.Changed += OnStateChanged;
        State.UiReset += OnUiReset;
        Invalidations.Invalidated += OnInvalidated;
    }
    
    void OnStateChanged() => _ = InvokeAsync(StateHasChanged);
    
    private void OnUiReset()
    {
        // Clear selection highlight & close toolbars
        _ = JS.InvokeVoidAsync("putdocEnh.clearSelected");
        _ = JS.InvokeVoidAsync("putdocEnh.closeAllToolbars");
        _ = InvokeAsync(StateHasChanged);
    }
    
    private void OnInvalidated(Guid docId, string actorSessionId, bool structural, int newRev)
    {
        if (State.CurrentDocId != docId) return;
        if (!structural) return;
        if (actorSessionId == _sessionId) return;
        _staleStructural = true;
        InvokeAsync(StateHasChanged);
    }

    public new void Dispose()
    {
        State.Changed -= OnStateChanged;
        Invalidations.Invalidated -= OnInvalidated;
        State.UiReset -= OnUiReset;
    }
    
    private ElementReference _scopeAnchor;
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Enhance & observe each snippet by its DOM id (idempotent on JS side)
        var page = State.CurrentPage(); 
        if (page == null) return;
        foreach (var snip in page.Snippets)
        {
            var domId = $"snip-{snip.Id}";
            await JS.InvokeVoidAsync("putdocEnh.observeById", domId);
        }

        if (firstRender)
        {
            _sessionId = await JS.InvokeAsync<string>("putdoc.getSessionId");
            await JS.InvokeVoidAsync("putdocEnh.initMyScopedEnhancements", _scopeAnchor);
        }


        // Clear previous highlight when page or selected snippet changed,
        // or when fragment mode just deactivated.
        var currentPageId = page.Id;
        var currentSelSnipId = State.SelectedSnippetId;

        var pageChanged = _lastPageId != currentPageId;
        var snippetChanged = _lastSelectedSnippetId != currentSelSnipId;

        if (pageChanged || snippetChanged || (!State.Selection.IsActive && _lastActive))
        {
            await JS.InvokeVoidAsync("putdocEnh.clearSelected");
            _lastPageId = currentPageId;
            _lastSelectedSnippetId = currentSelSnipId;
        }

        _lastActive = State.Selection.IsActive;

        // Re-highlight active fragment (if any)
        if (State.Selection.IsActive && !string.IsNullOrWhiteSpace(State.Selection.Selector))
        {
            await JS.InvokeVoidAsync("putdocEnh.markSelected", State.Selection.Selector);
        }
    }
}


<style>
    /* —— Inline toolbar host & trigger —— */
    .pd-toolbar-host { display: inline; vertical-align: baseline; }

    .pd-inline-toolbar { display: inline-flex; align-items: start; gap: .5rem; }

    /* when open: host becomes block → content after starts on a new line */
    .pd-toolbar-host:has(.pd-inline-toolbar[data-open="true"]) {
        display: block;
    }
    
    /*.pd-toolbar-row { display: flex; gap: .5rem; margin-left: .25rem; }*/
    
    /*.pd-inline-toolbar { display: inline; }*/
    .pd-inline-toolbar .pd-toolbar-panel { display: none; }               /* closed */
    .pd-inline-toolbar[data-open="true"] .pd-toolbar-panel { display: block; } /* open */

    .pd-gear.btn.drop {               /* reuse your .btn + .drop */
        width: 22px; height: 22px; line-height: 1; font-size: 14px; padding: 0;
        display: inline-flex; align-items: center; justify-content: center;
        margin-right: .375rem;
    }

    /* Panel adopts IndexPanel tokens */
    .pd-toolbar-panel.menu-popover {
        margin: .35rem 0;               /* matches your .menu-popover spacing */
        padding: .5rem;                 /* already set by .menu-popover */
    }

    /* Button spacing inside panel */
    .pd-toolbar-panel .btn { margin-right: .375rem; margin-bottom: .25rem; }
    .pd-toolbar-panel .btn:last-child { margin-right: 0; }

    /* Optional separators inside panel */
    .pd-toolbar-panel .sep { border-top: 1px solid #ccc; margin: .5rem 0; display: block; }

    
    /*.slf-card, .slf-brick, .prompt_area, li {*/
    /*    display: flex;             !* toolbar + body sit in a row *!*/
    /*    align-items: flex-start;*/
    /*    gap: .5rem;*/
    /*}*/

    /* keep the native bullet/number */
    li { display: list-item; list-style-position: outside; }

    /* --- LI rows (toolbar floated left by default) --- */
    li > putdoc-toolbar { float: left; margin-right: .5rem; }
    li > .pd-body { overflow: hidden; } /* BFC so text sits to the right of the float */

    /* When the toolbar is OPEN → put it on its own line, then the body below it */
    li > putdoc-toolbar:has(.pd-inline-toolbar[data-open="true"]) {
        float: none;              /* stop floating */
        display: block;           /* take the full line */
        margin-right: 0;
    }
    li > putdoc-toolbar:has(.pd-inline-toolbar[data-open="true"]) + .pd-body {
        clear: both;              /* force the content onto the next line */
    }

    /* --- Block wrappers (ul/ol/pre wrapped in .pd-row-wrap) --- */
    .pd-row-wrap { display: flex; gap: .5rem; align-items: flex-start; }
    .pd-row-wrap:has(> putdoc-toolbar .pd-inline-toolbar[data-open="true"]) {
        display: block;           /* stack: toolbar on its own line, then the block */
    }
    .pd-row-wrap:has(> putdoc-toolbar .pd-inline-toolbar[data-open="true"]) > putdoc-toolbar {
        margin-bottom: .35rem;    /* a little air above the list/pre */
    }


    /* make the content block establish a new BFC next to the float */
    li > .pd-row {
        display: flow-root;     /* modern clearfix/BFC */
        /* if flow-root isn't available in your target, use overflow:hidden; */
        /* overflow: hidden; */
    }

    /* the actual text container */
    li > .pd-row > .pd-body {
        min-width: 0;           /* allow wrapping, no horizontal scroll */
    }

    /* optional: vertically align first line with the gear */
    li > .pd-row,
    li > putdoc-toolbar { vertical-align: top; }

    /* whole-block wrapper for UL/OL/PRE stays flex (unchanged) */
    .pd-row-wrap {
        display: flex;
        align-items: flex-start;
        gap: .5rem;
    }
    .pd-row-wrap > ul,
    .pd-row-wrap > ol { margin: 0; padding-left: 1.25rem; }

    .pd-row,.pd-row-wrap { border: 1px solid #AAA; border-radius: 4px; }
    /* Custom element defaults (safe) */
    putdoc-toolbar { display: inline-block; }
    .pd-inline-toolbar { display: inline-flex; align-items: center; gap: .4rem; }

</style>