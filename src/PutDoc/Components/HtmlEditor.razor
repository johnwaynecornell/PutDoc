@namespace PutDoc.Components
@inject PutDoc.Services.PutDocState State
@inject DocWriterService Writer;
@inject IJSRuntime JS
@using PutDoc.Services
@implements IDisposable

<h3 class="font-semibold mb-2">HTML Editor</h3>

@if (_isFragmentMode)
{
    <div style="font-size:.85rem; color:#444; margin-bottom:.25rem; display:flex; gap:.5rem; align-items:center;">
        Editing fragment in snippet <code>@State.Selection.SnippetId</code>
        <span>• Scope:
            <button type="button" class="btn" @onclick="ToggleScope">
                @(_fragScope == PutDocState.FragmentScope.Inner ? "Inner" : "Outer")
            </button>
        </span>
        <button type="button" class="btn" @onclick="ExitFragment">Exit fragment</button>
    </div>
}

<div style="
  background-color:#FDD; padding:.5rem; border-radius:.5rem; margin-bottom:.5rem;
  border:1px solid #ECC; display:flex; flex-wrap:wrap; gap:.5rem; align-items:center;">

    <div class="palette">    
        <button type="button" class="btn" disabled="@(State.IsReadOnly)" @onclick='() => InsertTpl("card")'>+ slf-card</button>
        <button type="button" class="btn" disabled="@(State.IsReadOnly)" @onclick='() => InsertTpl("brick")'>+ slf-brick</button>
        <button type="button" class="btn" disabled="@(State.IsReadOnly)" @onclick='() => InsertTpl("prompt")'>+ prompt</button>
        <span class="sep" style="border-left:1px solid #ddd; height:1.25rem;"></span>
        <button type="button" class="btn" disabled="@(State.IsReadOnly)" @onclick='() => InsertTpl("table")'>+ table</button>
        <button type="button" class="btn" disabled="@(State.IsReadOnly)" @onclick='() => InsertTpl("list")'>+ list</button>
        <button type="button" class="btn" disabled="@(State.IsReadOnly)" @onclick='() => InsertTpl("p")'>+ paragraph</button>
        <span class="sep" style="border-left:1px solid #ddd; height:1.25rem;"></span>
        <button type="button" class="btn" disabled="@(State.IsReadOnly)" @onclick='() => PasteHtml()'>Paste Rich</button>
        <button type="button" class="btn" disabled="@(State.IsReadOnly)" @onclick='() => Beautify()'>Beautify</button>
        <button type="button" class="btn" disabled="@(State.IsReadOnly)" @onclick='() => Condense()'>Condense</button>
        
    </div>
    
    <!-- Tag inserter + taggify -->
    <form class="tag-inserter palette"
          style="overflow: visible;"
          @onsubmit="InsertTagFromUi" @onsubmit:preventDefault="true">
    
        @if (Rendered)
        {
            <input type="text"
                   name="tag" autocomplete="off" spellcheck="false"
                   class="tag-input"
                   placeholder='e.g., div  |  p class="note"  |  img src="" alt=""'
                   style="min-width:16rem; padding:.25rem .4rem; border:1px solid #ccc; border-radius:.375rem;"
                   @bind="tagInput"
                   @bind:event="oninput"
                   @ref="_tagInputRef" />
        }
    
        <button type="submit" class="btn">Insert tag</button>
      <button type="button" class="btn" @onclick="TaggifySelectionFromUi" title="Wrap current selection with tag">Taggify</button>
    </form>

    <!-- Save/Undo/Redo/Freeze row -->
    <div class="palette">
      <button type="button" class="btn" @onclick="SaveNow" disabled="@(State.IsReadOnly)">Save now</button>
      <button type="button" class="btn" @onclick="Undo" disabled="@(!_canUndo)">
          @("Undo" + (_canUndo && _undo[^1]?.Label is { } L ? $": {L}" : ""))
      </button>
      
      <button type="button" class="btn" @onclick="Redo" disabled="@(!_canRedo)">Redo</button>
      <button type="button" class="btn" @onclick="ToggleFreeze">
        @(_isFrozen ? "Unfreeze (enable save)" : "Freeze (pause save)")
      </button>

      @if (_isFrozen)
      {
        <span style="font-size:.85rem; color:#b56;">Frozen — changes won’t be saved.</span>
      }

      @if (State.IsDirty)
      {
        <span title="Unsaved changes" style="width:.5rem;height:.5rem;border-radius:50%;
              background:#e67; display:inline-block; margin-left:.3rem;"></span>
      }
    </div>
</div>
<textarea @ref="_ta"
          class="w-full"
          style="height: 12rem; width: 100%; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Courier New', monospace; padding: .5rem; border: 1px solid #ddd; border-radius: .5rem;"
          @bind="EditorText"
          @bind:event="oninput">
</textarea>

@code {
    protected bool Rendered = false;

    protected override async void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            await JS.InvokeVoidAsync("putdocText.bindTabIndent", _ta);
            await JS.InvokeVoidAsync("putdocText.initEditor", _ta);

            _selfRef = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("putdocText.bindEditorShortcuts", _ta, _selfRef);
            await JS.InvokeVoidAsync("putdocText.bindCaretNotify", _ta, _selfRef);
            Rendered = true;

            State.Goto = Goto;
            
            StateHasChanged(); // causes the input to render next frame
            return;
        }

        if (_comboHandle is null && Rendered)
        {
            // Build options once (use your EffectiveTagOptions)
            var options = EffectiveTagOptions.ToArray();
            _comboHandle = await JS.InvokeAsync<IJSObjectReference>("putdocCombo.init", _tagInputRef, options);
        }
    }

    
    private async void GotoAction(string obj)
    {
        await Goto(obj);
    }


}

    
    <style>
.pd-modal-backdrop {
  position: fixed; inset: 0; background: rgba(0,0,0,.25);
}
.pd-modal {
  position: fixed; left: 50%; top: 25%;
  transform: translateX(-50%);
  min-width: 22rem; max-width: 90vw;
  background: #fff; border: 1px solid #ccd; border-radius: .5rem;
  padding: .85rem;
  box-shadow: 0 10px 28px rgba(0,0,0,.18), 0 6px 10px rgba(0,0,0,.12);
}

.pd-combo { background:#fff; border:1px solid #ccc; border-radius:.375rem; box-shadow:0 6px 18px rgba(0,0,0,.08); }
.pd-combo-item { padding:.3rem .45rem; cursor:pointer; }
.pd-combo-item:hover { background:#f5f7ff; }

/*.pd-combo {*/
/*    background-color: rgba(255,196,128, .95);*/
/*    color: #000;*/
/*    border: 1px solid #444;*/
/*    border-radius: 12px;*/
/*    padding: .5em;*/
/*}*/

</style>


@if (_showConfirm)
{
    <div class="pd-modal-backdrop" @onclick="ConfirmCancel"></div>
    <div class="pd-modal" role="dialog" aria-modal="true" aria-labelledby="pdModalTitle">
        <h3 id="pdModalTitle" style="margin:0 0 .5rem 0;">Unsaved changes</h3>
        <p style="margin:.25rem 0 1rem 0;">@_confirmMessage</p>
        <div style="display:flex; gap:.5rem; justify-content:flex-end;">
            <button type="button" class="btn" @onclick="ConfirmCancel">Cancel</button>
            <button type="button" class="btn" @onclick="ConfirmDiscard">Discard</button>
            <button type="button" class="btn primary" @onclick="ConfirmSave" disabled="@_isFrozen">Save</button>
        </div>
    </div>
}

<div style="font-size:.8rem; color:#666; margin-top:.5rem;">
    @_statusText • Saved through AngleSoft filter.
</div>

@code {

    private DotNetObjectReference<HtmlEditor>? _selfRef; // for JS callbacks

    // ===== UI state & editor buffer =====
    private string editorText = "";
    private ElementReference _ta;
    private bool _isFragmentMode;
    private Guid? _lastSnippetId;

    // typing serials
    private long _inputSerial = 0;
    private long _inputSerialAtSave = 0;

    // save control
    private bool _isSaving = false;
    private bool _pendingSave = false;
    private string? _savingSnapshot;

    // debounce timer
    private System.Timers.Timer? _debounce;
    private const int DebounceMs = 600;

    // status
    private enum SaveState
    {
        Idle,
        Typing,
        Saving,
        Saved
    }

    private SaveState _saveState = SaveState.Idle;

    private string _statusText => _saveState switch
    {
        SaveState.Typing => "Typing…",
        SaveState.Saving => "Saving…",
        SaveState.Saved => "Saved",
        _ => ""
    };

    // selection/sync
    private long _lastSeenContentVersion;
    private PutDocState.FragmentScope _fragScope = PutDocState.FragmentScope.Inner;

    // caret/saves/epochs
    private long _saveEpoch = 0;
    private long _editVersion = 0;

    // ===== Freeze =====
    private bool _isFrozen = false;

    // Transform guard: prevent autosave/state sync from clobbering caret after Beautify/Condense
    private bool _isTransforming = false;


    // ===== Undo/Redo (ring-list style) =====
    private sealed record UndoEntry(string Text, int SelStart, int SelEnd, string? Label = null);

    private readonly List<UndoEntry> _undo = new();
    private readonly List<UndoEntry> _redo = new();
    private bool _canUndo => _undo.Count > 0;
    private bool _canRedo => _redo.Count > 0;
    private const int MaxUndo = 100;

    private async void OnCheckpointRequested(string label)
    {
        try
        {
            // Only checkpoint if editor text matches our known baseline;
            // if the user is mid-typing, your debounce will checkpoint soon anyway.
            if (string.Equals(editorText, _lastCheckpointText, StringComparison.Ordinal))
            {
                var caret = await JS.InvokeAsync<TextSelection>("putdocText.getCachedSel", _ta);
                UndoPush(new UndoEntry(_lastCheckpointText, caret.Start, caret.End, label));
                // Do NOT advance _lastCheckpointText here; baseline (pre-action) remains the same.
                // The upcoming mutation will reflect in editorText via State events and then
                // your regular flow will update baselines.
                StateHasChanged();
            }
            else
            {
                // If diverged, still push what we know—better to have a checkpoint than none.
                var caret = await JS.InvokeAsync<TextSelection>("putdocText.getCachedSel", _ta);
                UndoPush(new UndoEntry(_lastCheckpointText, caret.Start, caret.End, label));
                StateHasChanged();
            }
        }
        catch (Exception E)
        {
            Console.WriteLine("OnCheckpointRequested swallowed exception:" + E);
            // swallow—checkpointing should never block the action
        }
    }


    private void UndoPush(UndoEntry e)
    {
        if (_undo.Count >= MaxUndo) _undo.RemoveAt(0);
        _undo.Add(e);
    }

    private UndoEntry? UndoPop()
    {
        if (_undo.Count == 0) return null;
        var e = _undo[^1];
        _undo.RemoveAt(_undo.Count - 1);
        return e;
    }

    private void RedoPush(UndoEntry e) => _redo.Add(e);

    private UndoEntry? RedoPop()
    {
        if (_redo.Count == 0) return null;
        var e = _redo[^1];
        _redo.RemoveAt(_redo.Count - 1);
        return e;
    }

    private void RedoClear() => _redo.Clear();

    // baseline: last editor checkpoint (not necessarily persisted)
    private string _lastCheckpointText = "";

    // context key so we don’t mix undos across snippet/fragment
    private string _contextKey = "";

    // Baseline caret that corresponds to _lastCheckpointText
    private int _baselineCaretStart = 0;
    private int _baselineCaretEnd = 0;

    protected override void OnInitialized()
    {
        State.Changed += OnStateChanged;
        Writer.WriterChanged += WriterOnWriterChanged;
        State.CheckpointRequested += OnCheckpointRequested; // <—
        State.SaveRequested += OnSaveRequested;
        State.ContextChangeRequested += OnContextChangeRequestedAsync;
        State.UiReset += OnUiReset;

        // Hand the frozen flag to State for centralized checks
        State.IsFrozen = () => _isFrozen;
        // In HtmlEditor.razor
        State.ClearFrozen = () =>
        {
            // Invalidate any in-flight SaveAsync and coalesced debounces
            _saveEpoch++;
            _debounce?.Stop();

            _pendingSave = false; // don’t flush a queued save from pre-thaw
            _isSaving = false; // UI unstuck
            _isFrozen = false; // thaw

            _saveState = SaveState.Saved; // neutral visual state (will update if we SaveNow)
            StateHasChanged();
        };
        _ = SyncFromStateAsync(force: true);
    }

    private void WriterOnWriterChanged(Guid arg1, WriterInfo? arg2)
    {
        _ = InvokeAsync(() => StateHasChanged());
    }

    private void OnStateChanged() => _ = InvokeAsync(() => SyncFromStateAsync(force: false));

    private void OnUiReset()
    {
        // stop timers
        _debounce?.Stop();
        _debounce?.Dispose();
        _debounce = null;

        // clear editor-local state
        editorText = "";
        _isSaving = false;
        _pendingSave = false;
        _savingSnapshot = null;
        _saveState = SaveState.Idle;

        _isFragmentMode = false;
        _fragScope = PutDocState.FragmentScope.Inner;

        _lastSnippetId = null;
        _lastSeenContentVersion = 0;

        _inputSerial = 0;
        _inputSerialAtSave = 0;
        _saveEpoch = 0;
        _editVersion = 0;

        // undo/redo
        _undo.Clear();
        _redo.Clear();
        _lastCheckpointText = "";

        _ = InvokeAsync(StateHasChanged);
    }

    private async Task ToggleScope()
    {
        if (!await State.EnsureClearForTextChangeInternalAsync()) return;

        _fragScope = (_fragScope == PutDocState.FragmentScope.Inner)
            ? PutDocState.FragmentScope.Outer
            : PutDocState.FragmentScope.Inner;

        await State.SetSelectionScope(_fragScope);
        await SyncFromStateAsync(force: true);
    }

    // ---- INPUT ----
    private string EditorText
    {
        get => editorText;
        set
        {
            if (editorText == value) return;
            editorText = value;
            _editVersion++;
            _inputSerial++;
            _saveState = SaveState.Typing;

            State.MarkDirty();
            RedoClear(); // new edits kill redo
            StartDebounce(); // always start, even if frozen (we still checkpoint)
        }
    }

    private void StartDebounce()
    {
        _debounce?.Stop();
        _debounce ??= new System.Timers.Timer(DebounceMs) { AutoReset = false };
        _debounce.Elapsed -= DebouncedSave;
        _debounce.Elapsed += DebouncedSave;
        _debounce.Start();
    }

    private async void DebouncedSave(object? sender, System.Timers.ElapsedEventArgs e)
    {
        await InvokeAsync(async () =>
        {
            // 1) Always checkpoint first (even while frozen)
            await CreateUndoCheckpointAsync();

            // 2) If frozen, skip persistence
            if (_isFrozen) return;

            if (_isSaving)
            {
                _pendingSave = true;
                return;
            }

            await SaveAsync(false);

            if (_pendingSave)
            {
                _pendingSave = false;
                await SaveAsync(false);
            }
        });
    }

    // ---- STATE SYNC ----
    private string ComputeContextKey()
    {
        if (State.Selection.IsActive)
            return $"frag:{State.Selection.SnippetId}|{State.Selection.Selector}|{State.Selection.Scope}";
        var sid = State.CurrentSnippet()?.Id;
        return $"snip:{sid}";
    }

    private void EnsureContext()
    {
        var key = ComputeContextKey();
        if (!string.Equals(key, _contextKey, StringComparison.Ordinal))
        {
            _contextKey = key;
            _undo.Clear();
            _redo.Clear();
            _lastCheckpointText = editorText;
        }
    }



    private async Task SyncFromStateAsync(bool force)
    {
        var wasFragment = _isFragmentMode;
        _isFragmentMode = State.Selection.IsActive;

        // Don’t let external syncs stomp the buffer during a transform or while typing
        if (_isTransforming || _saveState == SaveState.Typing) return;

        if (_isFragmentMode)
        {
            _fragScope = State.Selection.Scope;

            if (!_isSaving)
            {
                UpdateEditorTextAndGotos(State.Selection.Html ?? "");

                _lastSnippetId = State.Selection.SnippetId;
                _lastSeenContentVersion = State.ContentVersion;
                _saveState = SaveState.Idle;

                EnsureContext();
                _lastCheckpointText = editorText;

                try
                {
                    var sel = await JS.InvokeAsync<TextSelection>("putdocText.getCachedSel", _ta);
                    _baselineCaretStart = sel.Start;
                    _baselineCaretEnd = sel.End;
                }
                catch (Exception E)
                {
                    Console.WriteLine("SyncFromStateAsync swallowed exception:" + E);
                    // swallow—checkpointing should never block the action
                }

                _baselineCaretStart = _baselineCaretEnd = 0;

                StateHasChanged();
            }

            return;
        }

        var snip = State.CurrentSnippet();
        var sid = snip?.Id;

        var externalChangeOnSameSnippet =
            State.LastUpdateSource == PutDocState.UpdateSource.External &&
            State.ContentVersion != _lastSeenContentVersion &&
            sid == _lastSnippetId;

        if ((force || sid != _lastSnippetId || wasFragment || externalChangeOnSameSnippet) && !_isSaving)
        {
            UpdateEditorTextAndGotos(snip?.Html ?? "");

            _lastSnippetId = sid;
            _lastSeenContentVersion = State.ContentVersion;
            _saveState = SaveState.Idle;

            EnsureContext();
            _lastCheckpointText = editorText;

            try
            {
                var sel = await JS.InvokeAsync<TextSelection>("putdocText.getCachedSel", _ta);
                _baselineCaretStart = sel.Start;
                _baselineCaretEnd = sel.End;
            }
            catch (Exception E)
            {
                Console.WriteLine("SyncFromStateAsync swallowed exception:" + E);
                _baselineCaretStart = _baselineCaretEnd = 0;
            }

            StateHasChanged();
        }
    }

    // ---- Checkpoint (always runs in debounce) ----
    private async Task CreateUndoCheckpointAsync()
    {
        EnsureContext();

        if (!string.Equals(editorText, _lastCheckpointText, StringComparison.Ordinal))
        {
            // Push the PRIOR baseline (text + its caret) onto undo:
            UndoPush(new UndoEntry(_lastCheckpointText, _baselineCaretStart, _baselineCaretEnd));

            // Advance the baseline to the NEW editor state + current caret
            var caret = await JS.InvokeAsync<TextSelection>("putdocText.getCachedSel", _ta);
            _lastCheckpointText = editorText;
            _baselineCaretStart = caret.Start;
            _baselineCaretEnd = caret.End;

            StateHasChanged();
        }
    }

    // ---- SAVE (no undo push here; checkpoint already advanced) ----
    private async Task SaveAsync(bool force = false)
    {
        if (State.IsReadOnly) return;

        // Keep autosave blocked during freeze; allow manual “Save now”
        if (_isFrozen && !force) return;

        // If a transform is in progress, skip save; debounce will re-run after transform
        if (_isTransforming) return;


        var myEpoch = ++_saveEpoch;
        var myEditVersionAtStart = _editVersion;

        var caretBefore = await JS.InvokeAsync<TextSelection>("putdocText.getSel", _ta);

        _isSaving = true;
        _savingSnapshot = editorText;
        _inputSerialAtSave = _inputSerial;
        _saveState = SaveState.Saving;
        StateHasChanged();

        bool userTyped = false;
        bool didRewriteBuffer = false;

        if (_isFragmentMode && State.Selection.IsActive)
        {
            var page = State.CurrentPage();
            var snip = page?.Snippets.FirstOrDefault(s => s.Id == State.Selection.SnippetId);
            if (snip is not null)
            {
                var newHtml = await HtmlTransformService.ReplaceFragmentByPuidAsync(
                    snip.Html ?? "",
                    State.Selection.Selector!,
                    _savingSnapshot!,
                    replaceOuter: State.Selection.Scope == PutDocState.FragmentScope.Outer);

                if (newHtml is not null)
                {
                    await State.SetSnippetHtml(newHtml, isRawFromEditor: false);

                }
            }

            await State.BeginFragmentEdit(State.Selection.SnippetId, State.Selection.Selector!, State.Selection.Scope);

            if (_inputSerial == _inputSerialAtSave)
            {
                var updated = await HtmlPuid.StripPuidsAsync(State.Selection.Html ?? "");
                if (!string.Equals(editorText, updated, StringComparison.Ordinal))
                {
                    UpdateEditorTextAndGotos(State.Selection.Html ?? "", updated);
                    didRewriteBuffer = true;
                }
                else UpdateGotos(State.Selection.Html ?? "", updated);
            }
            else userTyped = true;
        }
        else
        {
            await State.SetSnippetHtml(_savingSnapshot!, isRawFromEditor: true);

            if (_inputSerial == _inputSerialAtSave)
            {
                var cleaned = await HtmlPuid.StripPuidsAsync(State.CurrentSnippet()?.Html ?? "");
                if (!string.Equals(editorText, cleaned, StringComparison.Ordinal))
                {
                    UpdateEditorTextAndGotos(State.CurrentSnippet()?.Html ?? "", cleaned);

                    didRewriteBuffer = true;
                }
                else UpdateGotos(State.CurrentSnippet()?.Html ?? "", cleaned);
            }
            else userTyped = true;
        }

        State.ClearDirty();

        _saveState = SaveState.Saved;
        _isSaving = false;
        StateHasChanged();

        if (didRewriteBuffer && !userTyped && myEpoch == _saveEpoch)
        {
            var latest = await JS.InvokeAsync<TextSelection>("putdocText.getCachedSel", _ta);
            await JS.InvokeVoidAsync("putdocText.setSel", _ta, latest.Start, latest.End);
        }
    }

    private void OnSaveRequested()
    {
        // Checkpoint-first is already in SaveNow(); respect Freeze (your SaveNow has the guard)
        _ = InvokeAsync(SaveNow);
    }

    protected Dictionary<Guid, int> LabelsForGoto = new Dictionary<Guid, int>();

    protected async Task UpdateGotos(string html, string? stripped = null)
    {
        if (stripped == null) stripped = await HtmlPuid.StripPuidsAsync(html);
        List<Object> parsed = await HtmlPuid.ParsePuidsAsync(html, stripped);

        LabelsForGoto = new Dictionary<Guid, int>();
        int i = 0;
        foreach (object o in parsed)
        {
            if (o is string s) i += s.Length;
            if (o is Guid guid) LabelsForGoto[guid] = HtmlText.SeekFromAttribute(stripped, i, -1);
        }
    }

    protected async Task UpdateEditorTextAndGotos(string html, string? stripped = null)
    {
        if (stripped == null) stripped = await HtmlPuid.StripPuidsAsync(html);
        await UpdateGotos(html, stripped);

        editorText = stripped;
    }

    public async Task<bool> Goto(string _puid)
    {
        Guid puid = Guid.Parse(_puid.Substring(1));
        if (!LabelsForGoto.TryGetValue(puid, out var i)) return false;
        
        // Move caret
        await TextSelect(i);
        return true;
    }

    private TaskCompletionSource<PutDocState.ContextChangeDecision>? _confirmTcs;
    private bool _showConfirm;
    private string _confirmMessage = "You have unsaved changes. What would you like to do?";

// This is invoked by PutDocState.EnsureClearForTextChangeAsync()
    private Task<PutDocState.ContextChangeDecision> OnContextChangeRequestedAsync()
    {
        // If nothing to prompt (edge cases), allow proceed
        if (!_isFrozen && !State.IsDirty)
            return Task.FromResult(PutDocState.ContextChangeDecision.Proceed);

        _confirmTcs = new TaskCompletionSource<PutDocState.ContextChangeDecision>(TaskCreationOptions.RunContinuationsAsynchronously);
        _showConfirm = true;
        StateHasChanged();
        return _confirmTcs.Task;
    }

// Button actions used by the modal UI:
    private void ConfirmCancel()
    {
        _showConfirm = false;
        _confirmTcs?.TrySetResult(PutDocState.ContextChangeDecision.Cancel);
    }

    private async void ConfirmSave()
    {
        _showConfirm = false;
        if (_isFrozen)
            State.ClearFrozen?.Invoke();

        // Stop debounce and save immediately
        _debounce?.Stop();
        await SaveNow();

        _confirmTcs?.TrySetResult(PutDocState.ContextChangeDecision.Save);
    }

    private void ConfirmDiscard()
    {
        _showConfirm = false;
        if (_isFrozen)
            State.ClearFrozen?.Invoke();

        State.ClearDirty();

        _confirmTcs?.TrySetResult(PutDocState.ContextChangeDecision.Discard);
    }


    // ---- INSERTS ----
    private async Task InsertTpl(string kind)
    {
        var tpl = kind switch
        {
            "card" => "<div class=\"slf-card\"><h3>Title</h3><p><b>Purpose</b>: <span>...</span></p><div><b>Content</b>: <div>...</div></div></div>",
            "brick" => "<div class=\"slf-brick\"><h3>BRICK</h3><p><b>Definition</b>: <span>...</span></p><div><b>Example</b>: <div>...</div></div></div>",
            "prompt" => "<div class=\"prompt_area\"><h3>Prompt</h3><p>...</p></div>",
            "table" => "<table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr></tbody></table>",
            "list" => "<ul><li>Item 1</li><li>Item 2</li></ul>",
            _ => "<p>...</p>"
        };

        await JS.InvokeVoidAsync("putdocText.insertAtCaret", _ta, tpl);

        _saveState = SaveState.Typing;
        State.MarkDirty();
        StartDebounce();
        RedoClear();
    }

    private async Task PasteHtml()
    {
        string? html = await JS.InvokeAsync<string?>("putdoc.readClipboardHtmlOrNull");
        if (html == null) return;

        await JS.InvokeVoidAsync("putdocText.insertAtCaret", _ta, await HtmlSimplifier.SimplifyAsync(html));

        _saveState = SaveState.Typing;
        State.MarkDirty();
        StartDebounce();
        RedoClear();
    }

    private CancellationTokenSource? _flashCts;

    private async Task FlashTextCaret()
    {
        // cancel any in-flight flash so they don't stack
        _flashCts?.Cancel();
        _flashCts = new CancellationTokenSource();
        var token = _flashCts.Token;

        // First flash
        await JS.InvokeVoidAsync("putdocText.flashCaretMarker", _ta);
        await JS.InvokeVoidAsync("putdocText.flashCaretLine", _ta);

        try
        {
            // Wait roughly one full cycle (marker 800ms + line 900ms + a bit)
            await Task.Delay(1160, token);

            if (token.IsCancellationRequested) return;

            // Second flash
            await JS.InvokeVoidAsync("putdocText.flashCaretMarker", _ta);
            await JS.InvokeVoidAsync("putdocText.flashCaretLine", _ta);
        }
        catch (TaskCanceledException)
        {
            // ignore – a newer FlashTextCaret() call superseded this one
        }
    }

    public async Task TextSelect(int? start, int? end = null)
    {
        if (end==null) end = start;
        
        await JS.InvokeVoidAsync("putdocText.setSelAndCache", _ta, start, end);
        await JS.InvokeVoidAsync("putdocUtil.afterNextPaint");
        if (start != end) await JS.InvokeVoidAsync("putdocText.scrollToIndex", _ta, start, true);

        FlashTextCaret();

    }

    private async Task ApplyWhitespaceTransform(string a, string b)
    {
        // Begin atomic transform
        _isTransforming = true;
        _debounce?.Stop();
        _saveEpoch++; // cancel any in-flight save’s post-work

        var curCaret = await JS.InvokeAsync<TextSelection>("putdocText.getSel", _ta);
        
        // Directly set buffer without triggering external sync
        editorText = b;
        _saveState = SaveState.Typing; // ensure a save will occur
        State.MarkDirty();
        RedoClear();

        await InvokeAsync(StateHasChanged);

        await JS.InvokeVoidAsync("putdocUtil.settle");

        int? start = HtmlText.WhitespaceVariantsSync(a, b, curCaret.Start);
        int? end = HtmlText.WhitespaceVariantsSync(a, b, curCaret.End);

        if (start != null && end != null)
        {
            TextSelect(start, end);
        }

        // End atomic transform → restart debounce autosave
        _isTransforming = false;
        StartDebounce();    
    }

    private async Task Beautify()
    {
        await ApplyWhitespaceTransform(editorText, 
            (await HtmlTransformService.BeautifyAsync(editorText)).Trim()
            );
    }

    private async Task Condense()
    {
        await ApplyWhitespaceTransform(editorText, 
            (await HtmlTransformService.CondenseAsync(editorText)).Trim()
            );
    }
    
    private void ExitFragment()
    {
        State.CancelSelectionEdit();
        _ = JS.InvokeVoidAsync("putdocPresence?.releaseCurrent");
    }

    // ---- Freeze / Undo / Redo / SaveNow ----
    private void ToggleFreeze()
    {
        _isFrozen = !_isFrozen;
        if (!_isFrozen && State.IsDirty) SaveNow();
        StateHasChanged();
    }

    [JSInvokable] // called by putdoc.js (Ctrl/Cmd+Z)
    public Task InvokeUndo() => Undo();

    [JSInvokable] // called by putdoc.js (Ctrl+Y or Shift+Ctrl/Cmd+Z)
    public Task InvokeRedo() => Redo();

    [JSInvokable]
    public Task InvokeSaveNow() => SaveNow();

    private async Task Undo()
    {
        var entry = UndoPop();
        if (entry is null) return;

        var curCaret = await JS.InvokeAsync<TextSelection>("putdocText.getSel", _ta);
        RedoPush(new UndoEntry(editorText, curCaret.Start, curCaret.End));

        editorText = entry.Text;
        _lastCheckpointText = entry.Text;
        _baselineCaretStart = entry.SelStart;
        _baselineCaretEnd = entry.SelEnd;

        await InvokeAsync(StateHasChanged);
        //await JS.InvokeVoidAsync("putdocText.setSelAndCache", _ta, entry.SelStart, entry.SelEnd);
        
        await TextSelect(entry.SelStart, entry.SelEnd);

        _saveState = SaveState.Typing;
        State.MarkDirty();
        StartDebounce();

        await InvokeAsync(StateHasChanged);

    }

    private async Task Redo()
    {
        var entry = RedoPop();
        if (entry is null) return;

        var curCaret = await JS.InvokeAsync<TextSelection>("putdocText.getSel", _ta);
        UndoPush(new UndoEntry(editorText, curCaret.Start, curCaret.End));

        editorText = entry.Text;
        _lastCheckpointText = entry.Text;
        _baselineCaretStart = entry.SelStart;
        _baselineCaretEnd = entry.SelEnd;

        await InvokeAsync(StateHasChanged);
        //await JS.InvokeVoidAsync("putdocText.setSelAndCache", _ta, entry.SelStart, entry.SelEnd);
        
        await TextSelect(entry.SelStart, entry.SelEnd);

        _saveState = SaveState.Typing;
        State.MarkDirty();
        StartDebounce();
        await InvokeAsync(StateHasChanged);

    }

    [JSInvokable]
    public Task NotifyCaretChanged(int start, int end)
    {
        // Only update the baseline caret if the buffer matches the baseline text.
        // (If text diverged, the next checkpoint will snapshot current caret anyway.)
        if (string.Equals(editorText, _lastCheckpointText, StringComparison.Ordinal))
        {
            _baselineCaretStart = Math.Max(0, Math.Min(start, editorText.Length));
            _baselineCaretEnd = Math.Max(0, Math.Min(end, editorText.Length));
        }

        return Task.CompletedTask;
    }

    private async Task SaveNow()
    {
        if (State.NeedsRepairReview) return;
        _debounce?.Stop();

        // Still checkpoint first (even on explicit save), then persist if not frozen.
        await CreateUndoCheckpointAsync();
        if (_isFrozen) Console.WriteLine("[HtmlEditor] info");

        await SaveAsync(force: true);
    }

    // private async Task SaveNow()
    // {
    //     if (State.IsReadOnly) return;
    //     _debounce?.Stop();
    //
    //     // Still checkpoint first (even on explicit save), then persist if not frozen.
    //     await CreateUndoCheckpointAsync();
    //     if (_isFrozen) return;
    //
    //     await SaveAsync();
    // }


    public void Dispose()
    {
        State.Changed -= OnStateChanged;
        Writer.WriterChanged -= WriterOnWriterChanged;
        State.CheckpointRequested -= OnCheckpointRequested; // <—
        State.SaveRequested -= OnSaveRequested;
        State.ContextChangeRequested -= OnContextChangeRequestedAsync;
        State.UiReset -= OnUiReset;

        if (State.Goto == Goto) State.Goto = null;

        if (_debounce is not null)
        {
            _debounce.Stop();
            _debounce.Dispose();
            _debounce = null;
        }

        try
        {
            _ = JS.InvokeVoidAsync("putdocText.unbindEditorShortcuts", _ta);
        }
        catch
        {
            /* ignore */
        }

        try
        {
            _ = JS.InvokeVoidAsync("putdocText.unbindCaretNotify", _ta);
        }
        catch
        {
        }

        try
        {
            if (_comboHandle is not null) _ = _comboHandle.InvokeVoidAsync("dispose");
        }
        catch
        {
        }

        _comboHandle = null;

        _selfRef?.Dispose();
        _selfRef = null;
    }

    // ---- Tag inserter helpers ----
    [Parameter] public IEnumerable<string>? TagOptions { get; set; }

    private static readonly string[] DefaultTagOptions = new[]
    {
        "div", "p", "h1", "h2", "h3",
        "ul", "ol", "li",
        "pre", "code", "span", "strong", "em",
        "a href=\"\"",
        "img src=\"\" alt=\"\"",
        "table", "thead", "tbody", "tr", "th", "td",
        "section", "article", "aside", "header", "footer",
    };

    private IEnumerable<string> EffectiveTagOptions =>
        TagOptions is { } any && any.Any() ? TagOptions! : DefaultTagOptions;

    private string? _tagInput = null;

    private string? tagInput
    {
        get => _tagInput;
        set
        {
            _tagInput = value;
            //_ = InvokeAsync(StateHasChanged);
        }
    }

    private ElementReference _tagInputRef;
    private IJSObjectReference? _comboHandle;

    private static readonly HashSet<string> SelfClosing = new(StringComparer.OrdinalIgnoreCase)
    {
        "area", "base", "br", "col", "embed", "hr", "img", "input", "link",
        "meta", "param", "source", "track", "wbr"
    };

    private async Task InsertTagFromUi()
    {
        var raw = (_tagInput ?? "").Trim();
        if (string.IsNullOrEmpty(raw)) return;

        var markup = BuildClosedMarkup(raw);
        await JS.InvokeVoidAsync("putdocText.insertAtCaret", _ta, markup);

        _tagInput = "";
        _saveState = SaveState.Typing;
        State.MarkDirty();
        StartDebounce();
        RedoClear();
    }

    private async Task TaggifySelectionFromUi()
    {
        var raw = (_tagInput ?? "").Trim();
        if (string.IsNullOrEmpty(raw)) return;

        var (name, attrs, isVoid) = ParseTagSpec(raw);
        if (string.IsNullOrEmpty(name)) return;

        if (isVoid)
        {
            var standalone = attrs.Length > 0 ? $"<{name} {attrs} />" : $"<{name} />";
            await JS.InvokeVoidAsync("putdocText.insertAtCaret", _ta, standalone);
        }
        else
        {
            var open = attrs.Length > 0 ? $"<{name} {attrs}>" : $"<{name}>";
            var close = $"</{name}>";
            await JS.InvokeVoidAsync("putdocText.wrapSelection", _ta, open, close);
        }

        _saveState = SaveState.Typing;
        State.MarkDirty();
        StartDebounce();
        RedoClear();
    }

    private static string BuildClosedMarkup(string raw)
    {
        var s = raw.Trim();
        if (string.IsNullOrWhiteSpace(s)) return s;
        if (s.StartsWith("</") || s.Contains("</")) return s;
        if (s.StartsWith("<") && !s.EndsWith(">")) s += ">";
        if (!s.StartsWith("<"))
        {
            var name = ExtractTagName(s.AsSpan());
            var attrs = s.Length > name.Length ? s.Substring(name.Length).TrimStart() : "";
            if (SelfClosing.Contains(name))
                return attrs.Length > 0 ? $"<{name} {attrs} />" : $"<{name} />";
            var open = attrs.Length > 0 ? $"<{name} {attrs}>" : $"<{name}>";
            return $"{open}</{name}>";
        }

        if (s.EndsWith("/>")) return s;
        var nm = ExtractTagName(s.AsSpan(1));
        if (string.IsNullOrEmpty(nm)) return s;
        if (SelfClosing.Contains(nm))
        {
            if (!s.EndsWith("/>"))
            {
                s = s.TrimEnd('>');
                s += " />";
            }

            return s;
        }

        return s + $"</{nm}>";
    }

    private static (string name, string attrs, bool isVoid) ParseTagSpec(string raw)
    {
        var s = raw.Trim();
        if (s.StartsWith("</"))
        {
            var n = ExtractTagName(s.AsSpan(2));
            return (n, "", SelfClosing.Contains(n));
        }

        if (s.StartsWith("<")) s = s.TrimStart('<');
        if (s.EndsWith(">")) s = s.TrimEnd('>');
        if (s.EndsWith("/")) s = s.TrimEnd('/').TrimEnd();
        var name = ExtractTagName(s.AsSpan());
        var attrs = s.Length > name.Length ? s.Substring(name.Length).TrimStart() : "";
        return (name, attrs, SelfClosing.Contains(name));
    }

    private static string ExtractTagName(ReadOnlySpan<char> span)
    {
        int i = 0;
        while (i < span.Length && (span[i] == '<' || span[i] == '/' || char.IsWhiteSpace(span[i]))) i++;
        int start = i;
        while (i < span.Length)
        {
            char c = span[i];
            if (char.IsLetterOrDigit(c) || c == ':' || c == '-')
            {
                i++;
                continue;
            }

            break;
        }

        return (i > start) ? span.Slice(start, i - start).ToString() : "";
    }

    // Strongly-typed DTO for JS interop
    public record TextSelection(int Start, int End);

}
