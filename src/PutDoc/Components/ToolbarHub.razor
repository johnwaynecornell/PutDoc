@namespace PutDoc.Components
@inject PutDoc.Services.PutDocState State
@inject PutDoc.Services.PresenceService Presence
@inject PutDoc.Services.DocInvalidationService Invalidations
@inject DocWriterService Writers
@inject IJSRuntime JS
@using AngleSharp.Dom
@inject NavigationManager Nav
@implements IAsyncDisposable

@code {
    DotNetObjectReference<ToolbarHub>? _selfRef;
    string _clientId = "";
    string _sessionId = "";
    //string _userId => State.CurrentUserId ?? "local-user"; // adjust to your auth/user
    string _userId => "local-user"; // adjust to your auth/user

    // Track the current held lock (one at a time editor UX)
    LockKey? _heldKey;
    System.Threading.Timer? _hbTimer; //Presence
    System.Threading.Timer? _hb; //DocWriter
    bool _isWriter;
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender) return;

        _selfRef = DotNetObjectReference.Create(this);
        await JS.InvokeVoidAsync("putdocEnh.setHub", _selfRef);

        _sessionId = await JS.InvokeAsync<string>("putdoc.getSessionId");
        _clientId = await JS.InvokeAsync<string>("putdoc.getClientId");
        
        State.Changed += StateOnChanged;
        Writers.WriterChanged += WritersOnWriterChanged;
        
        await AcquireDocWriter(false);
    }

    private void WritersOnWriterChanged(Guid docId, WriterInfo? writerInfo)
    {
        if (State.CurrentDocId != docId) return;

        var isMe = writerInfo is not null && writerInfo.SessionId == _sessionId;
        State.SetReadOnly(!isMe);

        // Optional: if we lost write, close any open toolbars to avoid "dead" buttons
        if (!isMe)
            _ = JS.InvokeVoidAsync("putdocEnh.closeAllToolbars");

        _ = InvokeAsync(StateHasChanged);
    }

    private void StateOnChanged()
    {
        _ = InvokeAsync(StateHasChanged);
    }

    [JSInvokable]
    public async Task<object> AcquireDocWriter(bool force)
    {
        var docId = State.CurrentDocId;
        if (docId == Guid.Empty) return new { status = "error", message = "no doc" };

        var (res, prev) = Writers.TryBecomeWriter(docId, _userId, _sessionId, force);
        _isWriter = res is WriterResult.Granted or WriterResult.AlreadyYou or WriterResult.Stolen;

        State.SetReadOnly(!_isWriter);  // <-- add SetReadOnly(bool) on PutDocState if not present
        
        if (_isWriter)
        {
            _hb?.Dispose();
            _hb = new System.Threading.Timer(_ => {
                try { Writers.Heartbeat(docId, _sessionId); } catch {}
            }, null, TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(10));
        }

        return new { status = _isWriter ? "writer" : "readonly", prev = prev?.SessionId };
    }

    [JSInvokable]
    public object ReleaseDocWriter()
    {
        var docId = State.CurrentDocId;
        if (docId != Guid.Empty) Writers.Release(docId, _sessionId);
        _isWriter = false;
        State.SetReadOnly(true);
        _hb?.Dispose(); _hb = null;
        return new { status = "ok" };
    }

    // ===== Lock helpers =====

    static LockKey SnippetKey(Guid docId, Guid snippetId)
        => new(docId, $"snippet:{snippetId}");

    static LockKey FragmentKey(Guid docId, Guid snippetId, string puid, string scope /* "inner"|"outer" */)
        => new(docId, $"frag:{snippetId}:{puid}:{scope}");

    void StartHeartbeat(LockKey key)
    {
        StopHeartbeat();
        _heldKey = key;
        _hbTimer = new System.Threading.Timer(_ => {
            try { Presence.Heartbeat(key, _userId, _clientId); } catch { }
        }, null, dueTime: TimeSpan.FromSeconds(10), period: TimeSpan.FromSeconds(10));
    }

    void StopHeartbeat()
    {
        _hbTimer?.Dispose(); _hbTimer = null;
        _heldKey = null;
    }

    [JSInvokable]
    public async Task<object> OpenFragment(string kind /* "fragment-inner"/"fragment-outer" */,
        string puid,
        string snippetIdStr)
    {
        if (!Guid.TryParse(snippetIdStr, out var snippetId))
            return new { status = "error", message = "bad snippetId" };

        if (!await State.EnsureClearForTextChangeInternalAsync()) return new { status = "ok" };

        var scope = kind == "fragment-outer"
            ? PutDocState.FragmentScope.Outer
            : PutDocState.FragmentScope.Inner;

        await State.BeginFragmentEdit(snippetId, puid, scope);
        await JS.InvokeVoidAsync("putdocEnh.markSelected", puid);
        return new { status = "ok" };
    }
    
    [JSInvokable]
    public object AcquireForEdit(string kind /* "snippet"|"fragment-inner"|"fragment-outer" */, string puid, string snippetIdStr, bool force=false)
    {
        if (!Guid.TryParse(snippetIdStr, out var snippetId)) return new { status = "error", message = "bad snippetId" };
        var docId = State.CurrentDocId;
        if (docId == Guid.Empty) return new { status = "error", message = "no doc" };

        LockKey key = kind.StartsWith("fragment", StringComparison.OrdinalIgnoreCase)
            ? FragmentKey(docId, snippetId, puid ?? "", kind.EndsWith("outer", StringComparison.OrdinalIgnoreCase) ? "outer" : "inner")
            : SnippetKey(docId, snippetId);

        var (result, holder) = Presence.TryAcquire(key, _userId, _sessionId, force);

        switch (result)
        {
            case LockResult.Granted:
            case LockResult.AlreadyHeldByYou:
                StartHeartbeat(key);
                return new { status = "granted" };

            case LockResult.Stolen:
                StartHeartbeat(key);
                return new { status = "stolen", prev = new { user = holder?.OwnerUserId, client = holder?.OwnerClientId } };

            case LockResult.Denied:
                return new { status = "denied", holder = new { user = holder?.OwnerUserId, client = holder?.OwnerClientId } };

            default:
                return new { status = "error" };
        }
    }

    [JSInvokable]
    public object ReleaseCurrent()
    {
        if (_heldKey is { } key)
        {
            try { Presence.Release(key, _userId, _clientId); } catch { }
            StopHeartbeat();
            return new { status = "ok" };
        }
        return new { status = "noop" };
    }

    // ===== Actions (Auto-acquire for edit) =====

    [JSInvokable]
    public async Task<object> Handle(string action, string puid, string snippetIdStr)
    {
        if (!Guid.TryParse(snippetIdStr, out var snippetId)) return new { status = "error", message = "bad snippetId" };

        // Auto-acquire for edit actions
        if (action is "edit-inner" or "edit-outer")
        {
            if (!await State.EnsureClearForTextChangeInternalAsync()) return new { status = "ok" };

            var kind = action == "edit-outer" ? "fragment-outer" : "fragment-inner";
            var acquire = AcquireForEdit(kind, puid, snippetIdStr, force: false);
            if ((acquire as dynamic).status != "granted" && (acquire as dynamic).status != "stolen")
            {
                return acquire; // denied or error → let JS decide whether to prompt "Take over"
            }

            // proceed to open editor
            await State.BeginFragmentEdit(snippetId, puid, action == "edit-outer"
                ? PutDocState.FragmentScope.Outer
                : PutDocState.FragmentScope.Inner);

            await JS.InvokeVoidAsync("putdocEnh.markSelected", puid);
            return new { status = "ok" };
        }

        if (action == "copy")
        {
            await JS.InvokeVoidAsync("putdocEnh.copyByPuid", puid);
            
            return new { status = "ok" };
        }
        
        if (action == "copy")
        {
            IElement target = await HtmlTransformService.FetchTarget(State, snippetId, puid);
            if (target==null) return new { status = "error" };
         
            string text = await HtmlPuid.StripPuidsAsync(target.OuterHtml);
            await CopyToClipboard(text);
            
            return new { status = "ok" };
        }
        
        State.RequestCheckpoint(action);
        
        // Non-edit mutations delegate to your HtmlTransformService as before
        var ok = await HtmlTransformService.ApplyAsync(State, snippetId, action, puid);
        if (ok)
        {
            var structural = action is "clone" or "delete" or "up" or "down" or "edit-outer";
            if (structural && State.Doc is { } doc)
            {
                Invalidations.Bump(State.CurrentDocId, _sessionId, structural: true);
            }
            return new { status = "ok" };
        }
        return new { status = "error" };
    }
    
    async Task CopyToClipboard(string html) =>
        await JS.InvokeVoidAsync("navigator.clipboard.writeText", html);


    [JSInvokable]
    public Task<string> GetMenuHtml(string kind, string puid, string snippetIdStr)
    {
        // You can branch on 'kind' to tailor the menu.
        // Example: extra items for lists or <pre>.
        var extra = kind switch
        {
            "ul" => """<button type="button" class="btn" data-act="down">Outdent</button>""",
            "ol" => """<button type="button" class="btn" data-act="down">Outdent</button>""",
            "pre" => """<button type="button" class="btn" data-act="format-code">Format</button>""",
            _    => ""
        };

        var roAttr = State.IsReadOnly ? @"data-readonly=""true""" : "";
        var disable = State.IsReadOnly ? @"disabled=""disabled""" : "";
        
        // Note: keep Edit buttons enabled; structural actions are disabled when RO.
        var html = $@"
<div class=""menu-popover pd-toolbar-panel"" role=""menu"" data-kind=""{kind}"" {roAttr}>
  <div class=""toolbar-row"">
    <button type=""button"" class=""btn""        data-act=""copy"">Copy</button>
    <button type=""button"" class=""btn""        data-act=""edit-inner"">Edit</button>
    <button type=""button"" class=""btn""        data-act=""edit-outer"">Edit&nbsp;Outer</button>
    <span class=""sep""></span>
    <button type=""button"" class=""btn""        {disable} data-act=""clone"">Clone</button>
    <button type=""button"" class=""btn""        {disable} data-act=""up"">↑</button>
    <button type=""button"" class=""btn""        {disable} data-act=""down"">↓</button>
    <button type=""button"" class=""btn danger"" {disable} data-act=""delete"">Del</button>
    {extra}
  </div>
</div>";
        return Task.FromResult(html);
    }
    
    public async ValueTask DisposeAsync()
    {
        State.Changed -= StateOnChanged;
        
        try { ReleaseCurrent(); } catch { }
        StopHeartbeat();
        _selfRef?.Dispose();
        await Task.CompletedTask;
    }
}
