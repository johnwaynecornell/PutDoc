@namespace PutDoc.Components
@inject PutDoc.Services.PutDocState State
@inject PutDoc.Services.PresenceService Presence
@inject PutDoc.Services.DocInvalidationService Invalidations
@inject DocWriterService Writers
@inject IJSRuntime JS
@using AngleSharp.Dom
@inject NavigationManager Nav
@implements IAsyncDisposable

@code {
    DotNetObjectReference<ToolbarHub>? _selfRef;
    string _clientId = "";

    string _sessionId = "";

    //string _userId => State.CurrentUserId ?? "local-user"; // adjust to your auth/user
    string _userId => "local-user"; // adjust to your auth/user

    string _componentId = Guid.NewGuid().ToString("N");
    bool _isLeader = false;

    // Track the current held lock (one at a time editor UX)
    LockKey? _heldKey;
    System.Threading.Timer? _hbTimer; //Presence
    System.Threading.Timer? _hb; //DocWriter
    bool _isWriter;

    protected override void OnInitialized()
    {
        State.Changed += StateOnChanged;
        Writers.WriterChanged += WritersOnWriterChanged;
        State.UiReset += OnUiReset;

        base.OnInitialized();
    }
    
    private void OnUiReset()
    {
        try { ReleaseDocWriter(); } catch {}
        try { ReleaseCurrent(); } catch {}
        _isWriter = false;
        _hb?.Dispose(); _hb = null;
        _hbTimer?.Dispose(); _hbTimer = null;
        
        _heldKey = null;

        State.SetWriteBlock(true);
        _ = JS.InvokeVoidAsync("putdocEnh.closeAllToolbars");
        _ = InvokeAsync(StateHasChanged);
    }

    public bool _done_init = false;

    private async Task EnsureInitAsync()
    {
        if (_done_init) return;

        // 1) Claim leadership
        _isLeader = await JS.InvokeAsync<bool>("putdocEnh.claimLeader", _componentId);

        // 2) Get IDs (safe for both leaders and non-leaders; needed for logs)
        _sessionId = await JS.InvokeAsync<string>("putdoc.getSessionId");
        _clientId = await JS.InvokeAsync<string>("putdoc.getClientId");
        _done_init = !string.IsNullOrEmpty(_sessionId);

        Console.WriteLine($"[ToolbarHub] init: leader={_isLeader} session={_sessionId} client={_clientId}");

        // 3) Only the leader publishes the hub to JS
        if (_isLeader)
        {
            _selfRef = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("putdocEnh.setHub", _selfRef);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await EnsureInitAsync();
        // Nothing else needed here; actions happen when JS calls back into us or Writer events fire
    }

    public bool? HasWriter = null;
    
    private void WritersOnWriterChanged(Guid docId, WriterInfo? writerInfo)
    {
        if (!_isLeader) return; // only leader toggles read-only UI

        if (State.CurrentDocId != docId) return;
        if (string.IsNullOrEmpty(_sessionId)) return;

        var isMe = writerInfo is not null && writerInfo.SessionId == _sessionId;

        if (HasWriter != isMe)
        {
            HasWriter = isMe;
            State.SetWriteBlock(!isMe);

            Console.WriteLine($"[ToolbarHub] WritersOnWriterChanged: _sessionId={_sessionId} docId={docId} isMe={isMe}");
            if (!isMe)
                _ = JS.InvokeVoidAsync("putdocEnh.closeAllToolbars");
            _ = JS.InvokeVoidAsync("putdoc.toast", (isMe ? "Became" : "Lost") + " Writer");
        }

        //State.Notify();
        _ = InvokeAsync(StateHasChanged);
    }

    private void StateOnChanged() => _ = InvokeAsync(StateHasChanged);

    [JSInvokable]
    public async Task<object> AcquireDocWriter(bool force)
    {
        // Non-leaders do nothing user-visible; return current status
        await EnsureInitAsync();
        if (!_isLeader)
            return new { status = State.IsReadOnly ? "readonly" : "writer", note = "non-leader" };

        var docId = State.CurrentDocId;
        if (docId == Guid.Empty) return new { status = "error", message = "no doc" };

        var (res, _) = Writers.TryBecomeWriter(docId, _userId, _sessionId, force);
        State.Notify(() =>
        {
            _isWriter = res is WriterResult.Granted or WriterResult.AlreadyYou or WriterResult.Stolen;
            State.SetWriteBlock(!_isWriter);

            if (_isWriter)
            {
                _hb?.Dispose();
                _hb = new System.Threading.Timer(_ =>
                {
                    try
                    {
                        Writers.Heartbeat(docId, _sessionId);
                    }
                    catch
                    {
                    }
                }, null, TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(10));
            }
        });

        return new { status = _isWriter ? "writer" : "readonly" };
    }

    [JSInvokable]
    public object ReleaseDocWriter()
    {
        if (!_isLeader) return new { status = "ok", note = "non-leader" };

        if (_isWriter)
        {
            var docId = State.CurrentDocId;
            if (docId != Guid.Empty) Writers.Release(docId, _sessionId);
            _isWriter = false;
            State.SetWriteBlock(true);
        }

        _hb?.Dispose();
        _hb = null;
        return new { status = "ok" };
    }

    /*
    private void WritersOnWriterChanged(Guid docId, WriterInfo? writerInfo)
    {
        if (State.CurrentDocId != docId) return;

        if (_sessionId == "") return;

        var isMe = writerInfo is not null && writerInfo.SessionId == _sessionId;
        State.SetWriteBlock(!isMe);

        Console.WriteLine($"[ToolbarHub] WritersOnWriterChanged: docId={docId} _sessionId={_sessionId} _clientId={_clientId} isMe={isMe}");

        // Optional: if we lost write, close any open toolbars to avoid "dead" buttons
        if (!isMe)
            _ = JS.InvokeVoidAsync("putdocEnh.closeAllToolbars");

        _ = InvokeAsync(StateHasChanged);
    }

    private void StateOnChanged()
    {
        _ = InvokeAsync(StateHasChanged);
    }

    [JSInvokable]
    public async Task<object> AcquireDocWriter(bool force)
    {
        ensureInit();

        var docId = State.CurrentDocId;
        if (docId == Guid.Empty) return new { status = "error", message = "no doc" };

        var (res, prev) = Writers.TryBecomeWriter(docId, _userId, _sessionId, force);
        State.Notify(() =>
        {
            _isWriter = res is WriterResult.Granted or WriterResult.AlreadyYou or WriterResult.Stolen;

            State.SetWriteBlock(!_isWriter); // <-- add SetWriteBlock(bool) on PutDocState if not present

            if (_isWriter)
            {
                _hb?.Dispose();
                _hb = new System.Threading.Timer(_ =>
                {
                    try
                    {
                        Writers.Heartbeat(docId, _sessionId);
                    }
                    catch
                    {
                    }
                }, null, TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(10));
            }

        });

        return new { status = _isWriter ? "writer" : "readonly", prev = prev?.SessionId };
    }

    [JSInvokable]
    public object ReleaseDocWriter()
    {
        ensureInit();
        if (!_isWriter) return new { status = "ok" };;

        var docId = State.CurrentDocId;
        if (docId != Guid.Empty) Writers.Release(docId, _sessionId);
        _isWriter = false;
        State.SetWriteBlock(true);
        _hb?.Dispose(); _hb = null;
        return new { status = "ok" };
    }

    */
    // ===== Lock helpers =====

    static LockKey SnippetKey(Guid docId, Guid snippetId)
        => new(docId, $"snippet:{snippetId}");

    static LockKey FragmentKey(Guid docId, Guid snippetId, string puid, string scope /* "inner"|"outer" */)
        => new(docId, $"frag:{snippetId}:{puid}:{scope}");

    void StartHeartbeat(LockKey key)
    {
        if (!_isLeader) return;
        StopHeartbeat();
        _hbTimer = new System.Threading.Timer(_ =>
        {
            try
            {
                Presence.Heartbeat(key, _userId, _clientId);
            }
            catch
            {
            }
        }, null, TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(10));
    }

    void StopHeartbeat()
    {
        _hbTimer?.Dispose();
        _hbTimer = null;
    }

    [JSInvokable]
    public async Task<object> OpenFragment(string kind /* "fragment-inner"/"fragment-outer" */,
        string puid,
        string snippetIdStr)
    {
        if (!Guid.TryParse(snippetIdStr, out var snippetId))
            return new { status = "error", message = "bad snippetId" };

        if (!await State.EnsureClearForTextChangeInternalAsync()) return new { status = "ok" };

        var scope = kind == "fragment-outer"
            ? PutDocState.FragmentScope.Outer
            : PutDocState.FragmentScope.Inner;

        await State.BeginFragmentEdit(snippetId, puid, scope);
        await JS.InvokeVoidAsync("putdocEnh.markSelected", puid);
        return new { status = "ok" };
    }

    [JSInvokable]
    public object AcquireForEdit(string kind /* "snippet"|"fragment-inner"|"fragment-outer" */, string puid, string snippetIdStr, bool force = false)
    {
        if (!Guid.TryParse(snippetIdStr, out var snippetId)) return new { status = "error", message = "bad snippetId" };
        if (!_isLeader) return new { status = "readonly" }; // non-leader never contends locks

        var docId = State.CurrentDocId;
        if (docId == Guid.Empty) return new { status = "error", message = "no doc" };

        LockKey key = kind.StartsWith("fragment", StringComparison.OrdinalIgnoreCase)
            ? FragmentKey(docId, snippetId, puid ?? "", kind.EndsWith("outer", StringComparison.OrdinalIgnoreCase) ? "outer" : "inner")
            : SnippetKey(docId, snippetId);

        var (result, holder) = Presence.TryAcquire(key, _userId, _sessionId, force);

        switch (result)
        {
            case LockResult.Granted:
            case LockResult.AlreadyHeldByYou:
                StartHeartbeat(key);
                return new { status = "granted" };

            case LockResult.Stolen:
                StartHeartbeat(key);
                return new { status = "stolen", prev = new { user = holder?.OwnerUserId, client = holder?.OwnerClientId } };

            case LockResult.Denied:
                return new { status = "denied", holder = new { user = holder?.OwnerUserId, client = holder?.OwnerClientId } };

            default:
                return new { status = "error" };
        }
    }

    [JSInvokable]
    public object ReleaseCurrent()
    {
        if (!_isLeader) return new { status = "noop" };

        if (_heldKey is { } key)
        {
            try
            {
                Presence.Release(key, _userId, _clientId);
            }
            catch
            {
            }

            StopHeartbeat();
            return new { status = "ok" };
        }

        return new { status = "noop" };
    }

    // ===== Actions (Auto-acquire for edit) =====

    [JSInvokable]
    public async Task<object> Handle(string action, string puid, string snippetIdStr)
    {
        if (!Guid.TryParse(snippetIdStr, out var snippetId)) return new { status = "error", message = "bad snippetId" };

        if (action is "edit-inner" or "edit-outer")
        {
            if (!await State.EnsureClearForTextChangeInternalAsync()) return new { status = "ok" };

            if (_isLeader)
            {
                var kind = action == "edit-outer" ? "fragment-outer" : "fragment-inner";
                var acquire = AcquireForEdit(kind, puid, snippetIdStr, force: false);
                var status = (acquire as dynamic).status as string;
                if (status != "granted" && status != "stolen")
                    return acquire;
            }

            await State.BeginFragmentEdit(snippetId, puid, action == "edit-outer"
                ? PutDocState.FragmentScope.Outer
                : PutDocState.FragmentScope.Inner);

            await JS.InvokeVoidAsync("putdocEnh.markSelected", puid);
            return new { status = "ok" };
        }

        if (action == "copy")
        {
            // Use your cleaner copy (no duplicate branch)
            var target = await HtmlTransformService.FetchTarget(State, snippetId, puid);
            if (target is null) return new { status = "error" };
            var text = await HtmlPuid.StripPuidsAsync(target.OuterHtml);
            await JS.InvokeVoidAsync("navigator.clipboard.writeText", text);
            return new { status = "ok" };
        }

        if (action == "goto")
        {
            State.SelectSnippet(snippetId);
            //await Task.Yield();
            State.Notify();
            
            State.GotoAction(puid);
            
            return new { status = "ok" };
        }
        
        // Structural edits only make sense for the leader; non-leaders return readonly
        if (!_isLeader) return new { status = "readonly" };

        State.RequestCheckpoint(action);

        if (action == "paste-before")
        {
            string html = await JS.InvokeAsync<string>("putdoc.readClipboardText"); 
        
            var parsed = PutDocDetect.ParsePageOrCollection(html);
            switch (parsed.Kind)
            {
                case ExportPayloadKind.Page:
                {
                    _ = JS.InvokeVoidAsync("putdoc.toast", "Page before text makes no sense");
                    return new { status = "ok" };
                    break;
                }
                case ExportPayloadKind.Collection:
                {
                    _ = JS.InvokeVoidAsync("putdoc.toast", "Collection before text makes no sense");
                    return new { status = "ok" };
                    break;
                }
                default:
                    break;
            }
            
            await HtmlTransformService.InsertBeforeAsync(State, snippetId, puid, html);
        }
        else
        {
            var ok = await HtmlTransformService.ApplyAsync(State, snippetId, action, puid);
            if (!ok) return new { status = "error" };
        }

        var structural = action is "paste-before" or "clone" or "delete" or "up" or "down" or "edit-outer";
        if (structural)
            Invalidations.Bump(State.CurrentDocId, _sessionId, structural: true);

        return new { status = "ok" };
    }

    public async ValueTask DisposeAsync()
    {
        Console.WriteLine("[ToolbarHub] DisposeAsync");

        // Only leader clears hub and releases leadership
        if (_isLeader)
        {
            try
            {
                ReleaseDocWriter();
            }
            catch
            {
            }

            try
            {
                await JS.InvokeVoidAsync("putdocEnh.clearHub", _selfRef);
            }
            catch
            {
            }

            try
            {
                await JS.InvokeVoidAsync("putdocEnh.releaseLeader", _componentId);
            }
            catch
            {
            }
        }

        State.Changed -= StateOnChanged;
        Writers.WriterChanged -= WritersOnWriterChanged;
        State.UiReset -= OnUiReset;
        
        _hb?.Dispose();
        _hb = null;

        _hbTimer?.Dispose();
        _hbTimer = null;

        _selfRef?.Dispose();
    }
    
    async Task CopyToClipboard(string html) =>
        await JS.InvokeVoidAsync("navigator.clipboard.writeText", html);


    [JSInvokable]
    public Task<string> GetMenuHtml(string kind, string puid, string snippetIdStr)
    {
        // You can branch on 'kind' to tailor the menu.
        // Example: extra items for lists or <pre>.
        var extra = kind switch
        {
            "ul" => """<button type="button" class="btn" data-act="down">Outdent</button>""",
            "ol" => """<button type="button" class="btn" data-act="down">Outdent</button>""",
            "pre" => """<button type="button" class="btn" data-act="format-code">Format</button>""",
            _    => ""
        };

        var roAttr = State.IsReadOnly ? @"data-readonly=""true""" : "";
        var disable = (State.IsReadOnly || (State.IsFrozen != null && State.IsFrozen())) ? @"disabled=""disabled""" : "";
        
        // Note: keep Edit buttons enabled; structural actions are disabled when RO.
        var html = $@"
<div class=""menu-popover pd-toolbar-panel"" role=""menu"" data-kind=""{kind}"" {roAttr}>
  <div class=""toolbar-row"">
    <button type=""button"" class=""btn""        {disable} data-act=""paste-before"">Paste before</button>

    <button type=""button"" class=""btn""        data-act=""copy"">Copy</button>
    <button type=""button"" class=""btn""        data-act=""edit-inner"">Edit</button>
    <button type=""button"" class=""btn""        data-act=""edit-outer"">Edit&nbsp;Outer</button>
    <button type=""button"" class=""btn""        data-act=""goto"">goto</button>
    <span class=""sep""></span>
    <button type=""button"" class=""btn""        {disable} data-act=""clone"">Clone</button>
    <button type=""button"" class=""btn""        {disable} data-act=""up"">↑</button>
    <button type=""button"" class=""btn""        {disable} data-act=""down"">↓</button>
    <button type=""button"" class=""btn danger"" {disable} data-act=""delete"">Del</button>
    {extra}
  </div>
</div>";
        return Task.FromResult(html);
    }
    
}
