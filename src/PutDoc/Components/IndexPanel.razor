@using System.Text.Json
@namespace PutDoc.Components
@inject PutDoc.Services.PutDocState State
@inject IJSRuntime JS

<h3 class="font-semibold mb-2">Index</h3>

@if (Root is not null)
{
    <div class="text-sm">
        @RenderCollection(null, Root)
    </div>
}
else { <em>Missing root collection.</em> }

@code {
    // one open menu (collection or page) at a time
    Guid? _menuOpenFor;

    Collection? Root => State.Doc.Collections.TryGetValue(State.Doc.RootCollectionId, out var l) ? l : null;

    void ToggleMenuFor(Guid id) => _menuOpenFor = (_menuOpenFor == id) ? null : id;

    //Dictionary<bool, string> up_dn = new Dictionary<bool, string>() { { true, "‚ñ≥" }, {false, "‚ñΩ"} };
    Dictionary<bool, string> up_dn = new Dictionary<bool, string>() { { true, "‚ñ≤" }, {false, "‚ñº"} };
    
    RenderFragment RenderCollection(Collection parent, Collection collection) => __builder =>
    {
        <details open class="collection">
            <summary class="collection-row">
                <button type="button" class="btn drop" @onclick="() => ToggleMenuFor(collection.Id)">
                    @(up_dn[_menuOpenFor == collection.Id])
                </button>
                <span>üìÅ</span>
                <input value="@collection.Title"
                       @onchange="(e => State.RenameCollection(collection.Id, e.Value?.ToString() ?? collection.Title))"
                       class="collection-title" />
            </summary>

            @if (_menuOpenFor == collection.Id)
            {
                <div class="menu-popover">
                    <button type="button" class="btn" disabled="@State.IsReadOnlyOrFrozen" @onclick="() => PasteIntoCollection(collection.Id) ">Paste Into</button>
                    
                    @if (parent != null)
                    {

                        <button type="button" class="btn" disabled="@State.IsReadOnlyOrFrozen" @onclick="() => PasteBeforeCollection(parent.Id, collection.Id)">Paste before</button>
                    }
                    
                    <button type="button" class="btn" @onclick="() => CopyCollectionJson(collection.Id) ">Copy</button>
                    
                    @if (parent != null)
                    {
                        <button type="button" class="btn" title="Move Up" disabled="@State.IsReadOnlyOrFrozen" @onclick="() => State.MoveCollection(parent.Id, collection.Id, -1)">‚Üë</button>
                        <button type="button" class="btn" title="Move Down" disabled="@State.IsReadOnlyOrFrozen" @onclick="() => State.MoveCollection(parent.Id, collection.Id, +1)">‚Üì</button>
                    }

                    <button type="button" class="btn" disabled="@State.IsReadOnlyOrFrozen" @onclick="() => State.CreatePage(collection.Id)">+ Page</button>
                    <button type="button" class="btn" disabled="@State.IsReadOnlyOrFrozen" @onclick="() => State.CreateCollection(collection.Id)">+ Collection</button>
                    
                    @if (parent != null)
                    {
                        <button type="button" class="btn danger" title="Delete" disabled="@State.IsReadOnlyOrFrozen" @onclick="() => State.DeleteCollection(collection.Id)">üóë Delete</button>
                    }
                </div>
            }

            @if (collection.ChildCollectionIds?.Count > 0)
            {
                <div class="child-collections">
                    @foreach (var cid in collection.ChildCollectionIds)
                    {
                        if (!State.Doc.Collections.TryGetValue(cid, out var child)) continue;
                        @RenderCollection(collection, child)
                    }
                </div>
            }

            @if (collection.PageIds?.Count > 0)
            {
                <ul class="page-list">
                    @foreach (var pid in collection.PageIds)
                    {
                        if (!State.Doc.Pages.TryGetValue(pid, out var p)) continue;
                        var active = State.SelectedPageId == pid;
                        <li class="page-item @(active ? "active" : null)">
                            <div class="page-row">
                                <button type="button" class="btn drop" @onclick="() => ToggleMenuFor(pid)">
                                    @(up_dn[_menuOpenFor == pid])
                                </button>
                                <button type="button" class="page-link @(active ? "active" : null)"
                                        @onclick="() => State.TrySelectPageAsync(pid)">
                                    üìÑ @p.Title
                                </button>
                            </div>

                            @if (_menuOpenFor == pid)
                            {
                                <div class="menu-popover">
                                    <button type="button" class="btn" disabled="@State.IsReadOnlyOrFrozen" @onclick="() => PasteBeforePage( collection.Id, pid)">Paste before</button>
                                    
                                    <button type="button" class="btn" title="Rename" disabled="@State.IsReadOnlyOrFrozen" @onclick="() => PromptRenamePage(pid, p.Title)">‚úé Rename</button>
                                    <button type="button" class="btn" title="Copy" @onclick="() => CopyPageJson(pid)">Copy</button>
                                    <button type="button" class="btn" title="Move Up" disabled="@State.IsReadOnlyOrFrozen" @onclick="() => State.MovePage(collection.Id, pid, -1)">‚Üë</button>
                                    <button type="button" class="btn" title="Move Down" disabled="@State.IsReadOnlyOrFrozen" @onclick="() => State.MovePage(collection.Id, pid, +1)">‚Üì</button>
                                    <button type="button" class="btn" title="Clone" disabled="@State.IsReadOnlyOrFrozen" @onclick="() => State.ClonePage(collection.Id, pid)">‚ßâ Clone</button>
                                    <button type="button" class="btn danger" title="Delete" disabled="@State.IsReadOnlyOrFrozen" @onclick="() => State.DeletePage(collection.Id, pid)">üóë Delete</button>
                                    <span class="sep"></span>
                                    <button type="button" class="btn primary" title="Paste HTML as new snippet" disabled="@State.IsReadOnlyOrFrozen" @onclick="() => PasteIntoPage(pid)">üìã Paste into Page</button>
                                </div>
                            }
                        </li>
                    }
                </ul>
            }
        </details>;
    };

    async Task PromptRenamePage(Guid pageId, string current)
    {
        var title = await JS.InvokeAsync<string>("prompt", "Rename page:", current);
        if (!string.IsNullOrWhiteSpace(title))
            await State.RenamePage(pageId, title);
    }

    async Task PasteIntoPage(Guid pageId)
    {
        var html = await JS.InvokeAsync<string>("putdoc.readClipboardText");
        if (string.IsNullOrWhiteSpace(html)) return;
        await State.AddSnippetToPage(pageId, html);   // selects new snippet & updates editor via Notify()
    }

    async void CopyCollectionJson(Guid currentCollectionId)
    {
        string json = PutDocExport.ExportCollectionDeep(State.Doc, currentCollectionId);
        await JS.InvokeVoidAsync("navigator.clipboard.writeText", json);
    }
    
    async void CopyPageJson(Guid page_id)
    {
        string json = PutDocExport.ExportPageComplete(State.Doc.Pages[page_id]);
        await JS.InvokeVoidAsync("navigator.clipboard.writeText", json);
    }

    
    async void PasteIntoCollection(Guid currentCollectionId, string? json=null, bool overwrite = false)
    {
        if (json == null) json = await JS.InvokeAsync<string>("putdoc.readClipboardText"); 
        
        var parsed = PutDocDetect.ParsePageOrCollection(json);
        switch (parsed.Kind)
        {
            case ExportPayloadKind.Page:
            {
                var page = PutDocImport.ImportPageComplete(State.Doc, parsed.Page!, overwrite, newGuid: true);
                var coll = State.Doc.Collections[currentCollectionId];
                if (!coll.PageIds.Contains(page.Id)) coll.PageIds.Add(page.Id);
                _ = State.SaveAsync();
                State.Notify();
                break;
            }
            case ExportPayloadKind.Collection:
            {
                // Attach imported subtree under the current collection
                PutDocImport.ImportCollectionDeep(State.Doc, JsonSerializer.Serialize(parsed.Collection!, PutDocJson.Pretty),
                    attachTo: currentCollectionId, overwrite: overwrite, true);
                _ = State.SaveAsync();
                State.Notify();
                break;
            }
            default:
                throw new InvalidDataException("Unrecognized export JSON. Expecting Page or Collection.");
                break;
        }
    }

    async void PasteBeforeCollection(Guid parentId, Guid currentCollectionId, string? json=null, bool overwrite = false)
    {
        if (!State.Doc.Collections.TryGetValue(currentCollectionId, out var collection)) return;
        if (!State.Doc.Collections.TryGetValue(parentId, out var parent)) return;

        if (json == null) json = await JS.InvokeAsync<string>("putdoc.readClipboardText"); 
        
        var parsed = PutDocDetect.ParsePageOrCollection(json);
        switch (parsed.Kind)
        {
            case ExportPayloadKind.Page:
            {
                _ = JS.InvokeVoidAsync("putdoc.toast", "Page before Collection makes no sense");
                break;
            }
            case ExportPayloadKind.Collection:
            {
                // Attach imported subtree under the current collection
                var C = PutDocImport.ImportCollectionDeep(State.Doc, JsonSerializer.Serialize(parsed.Collection!, PutDocJson.Pretty),
                    attachTo: parentId, overwrite: overwrite, true);

                parent.ChildCollectionIds.Remove(C.Id);
                parent.ChildCollectionIds.Insert(parent.ChildCollectionIds.FindIndex(cuid => cuid == currentCollectionId), C.Id);
                
                _ = State.SaveAsync();
                State.Notify();
                break;
            }
            default:
                _ = JS.InvokeVoidAsync("putdoc.toast", "Text before Collection makes no sense");
                break;
        }
    }

    async void PasteBeforePage(Guid parentId, Guid currentPageId, string? json=null, bool overwrite = false)
    {
        if (!State.Doc.Pages.TryGetValue(currentPageId, out var curPage)) return;
        if (!State.Doc.Collections.TryGetValue(parentId, out var parent)) return;

        if (json == null) json = await JS.InvokeAsync<string>("putdoc.readClipboardText"); 
        
        var parsed = PutDocDetect.ParsePageOrCollection(json);
        switch (parsed.Kind)
        {
            case ExportPayloadKind.Page:
            {
                var page = PutDocImport.ImportPageComplete(State.Doc, parsed.Page!, overwrite, newGuid: true);
                parent.PageIds.Insert(parent.PageIds.FindIndex(cuid => cuid == currentPageId), page.Id);
                
                _ = State.SaveAsync();
                State.Notify();

                break;
            }
            case ExportPayloadKind.Collection:
            {
                _ = JS.InvokeVoidAsync("putdoc.toast", "Collection before Page makes no sense");
                break;
            }
            default:
                _ = JS.InvokeVoidAsync("putdoc.toast", "Text before Page makes no sense");
                break;
        }
    }


    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender) State.Changed += StateOnChanged;
        return base.OnAfterRenderAsync(firstRender);
    }

    private void StateOnChanged()
    {
        _ = InvokeAsync(() => StateHasChanged());
    }

    public void Dispose()
    {
        State.Changed -= StateOnChanged;
    }


}

<style>
.drop { min-width: 2rem; color: #8A8; }
.collection { font-weight:700; background-color: rgba(196,196,128,0.2);
        border:2px dashed #444; border-radius:16px; padding:.25rem .5rem; }
.collection-row { display:flex; align-items:center; gap:.5rem; }
.collection-title { border:0; border-bottom:1px dashed #ccc; outline:none; background:transparent; width:14rem; }
.page-list { list-style:none; padding-left:1rem; margin:.25rem 0; }
.page-item { margin:.25rem 0; border-radius:.5rem; }
.page-item.active { font-weight:700; border:1px solid #333; background-color: rgba(196,128,96,0.2); }
.page-row { display:flex; align-items:center; gap:.35rem; }
.page-link { background:none; border:0; text-decoration:underline; cursor:pointer; }
.page-link.active { font-weight:700; text-decoration:none; }
.menu-popover { background-color:#ffc; border:1px solid #ccc; border-radius:.5rem; padding:.5rem; margin:.35rem 0; }
.sep { border-top:1px solid #ccc; margin:.5rem 0; display:block; }
.btn { padding:.15rem .5rem; border:1px solid #ccc; border-radius:.375rem; background:#fff; cursor:pointer; }
.btn:hover { background:#f4f4f4; }
.btn.primary { border-color:#5b9; }
.btn.danger { border-color:#c77; }
.child-collections { margin-left:1rem; }
</style>
